<!-- This is an experemental antenna calculation tool written largely by Generative AI. Use at your own risk. As this is written by Generative AI, I am disavowing any copyright on it. -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Wire Antenna Designer</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 900px;
            margin: 20px auto;
            padding: 20px;
        }
        .section {
            margin-bottom: 20px;
        }
        label {
            display: block;
            margin: 5px 0;
        }
        button {
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
        }
        button:hover {
            background-color: #45a049;
        }
        #results {
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #ddd;
        }
        .hidden {
            display: none;
        }
        .remove-btn {
            background-color: #f44336;
            margin-left: 10px;
            padding: 5px 10px;
        }
        .remove-btn:hover {
            background-color: #da190b;
        }
        #antennaCanvas {
            border: 1px solid #000;
            margin-top: 20px;
        }
        .element-container {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        .tab {
            overflow: hidden;
            border: 1px solid #ccc;
            background-color: #f1f1f1;
        }
        .tab button {
            background-color: inherit;
            float: left;
            border: none;
            outline: none;
            cursor: pointer;
            padding: 14px 16px;
            transition: 0.3s;
        }
        .tab button:hover {
            background-color: #ddd;
        }
        .tab button.active {
            background-color: #ccc;
        }
        .tabcontent {
            display: none;
            padding: 6px 12px;
            border: 1px solid #ccc;
            border-top: none;
        }
    </style>
</head>
<body>
    <h1>Advanced Wire Antenna Designer</h1>
    
    <div class="section">
        <h2>Input Parameters</h2>
        <label>
            Primary Frequency (MHz):
            <input type="number" id="frequency" step="0.1" min="0.1" value="14.2">
        </label>
        <label>
            Antenna Type:
            <select id="antennaType" onchange="toggleAdvancedOptions()">
                <option value="dipole">Half-Wave Dipole</option>
                <option value="quarterVertical">Quarter-Wave Vertical</option>
                <option value="foldedDipole">Folded Dipole</option>
                <option value="fanDipole">Fan Dipole</option>
                <option value="hybrid">Hybrid (Custom Elements)</option>
                <option value="endFed">End-Fed Wire</option>
            </select>
        </label>
        <label>
            Velocity Factor (0-1, default 0.95 for bare wire):
            <input type="number" id="velocityFactor" step="0.01" min="0" max="1" value="0.95">
        </label>
        <label>
            Wire Material:
            <select id="wireMaterial">
                <option value="copper">Copper (VF: 0.95)</option>
                <option value="aluminum">Aluminum (VF: 0.93)</option>
                <option value="insulated">Insulated Copper (VF: 0.90)</option>
            </select>
        </label>
        <label>
            Wire Gauge (AWG):
            <input type="number" id="wireGauge" min="6" max="30" value="14">
        </label>
        <label>
            Use Balun/UnUn:
            <input type="checkbox" id="useBalun">
        </label>
        <label>
            Use Traps (for multi-band):
            <input type="checkbox" id="useTraps" onchange="toggleTrapOptions()">
        </label>
        <div id="trapOptions" class="hidden">
            <h3>Trap Frequencies</h3>
            <div id="trapFrequencies"></div>
            <button onclick="addTrapFrequency()">Add Trap Frequency</button>
        </div>

        <!-- Advanced Options for Fan Dipole -->
        <div id="fanDipoleOptions" class="hidden">
            <h3>Fan Dipole Elements</h3>
            <div id="fanFrequencies"></div>
            <button onclick="addFanFrequency()">Add Frequency</button>
        </div>

        <!-- Advanced Options for Hybrid -->
        <div id="hybridOptions" class="hidden">
            <h3>Hybrid Elements</h3>
            <div id="hybridElements"></div>
            <button onclick="addHybridElement()">Add Element</button>
        </div>

        <button onclick="calculateAntenna()">Calculate</button>
    </div>

    <div id="results">
        <h2>Results</h2>
        <div class="tab">
            <button class="tablinks" onclick="openTab(event, 'Design')" id="defaultOpen">Design</button>
            <button class="tablinks" onclick="openTab(event, 'Calculations')">Calculations</button>
        </div>

        <div id="Design" class="tabcontent">
            <p id="resultText">Enter parameters and click Calculate to see results.</p>
            <canvas id="antennaCanvas" width="600" height="400"></canvas>
        </div>

        <div id="Calculations" class="tabcontent">
            <p id="calculationText">Calculations will appear here after clicking Calculate.</p>
        </div>
    </div>

    <script>
        let fanFreqCount = 0;
        let hybridElementCount = 0;
        let trapFreqCount = 0;

        function toggleAdvancedOptions() {
            const antennaType = document.getElementById('antennaType').value;
            document.getElementById('fanDipoleOptions').classList.toggle('hidden', antennaType !== 'fanDipole');
            document.getElementById('hybridOptions').classList.toggle('hidden', antennaType !== 'hybrid');
            if (antennaType === 'fanDipole' && fanFreqCount === 0) {
                addFanFrequency();
            }
            if (antennaType === 'hybrid' && hybridElementCount === 0) {
                addHybridElement();
            }
            toggleTrapOptions();
        }

        function toggleTrapOptions() {
            const useTraps = document.getElementById('useTraps').checked;
            const antennaType = document.getElementById('antennaType').value;
            document.getElementById('trapOptions').classList.toggle('hidden', !useTraps || !['fanDipole', 'hybrid'].includes(antennaType));
            if (useTraps && ['fanDipole', 'hybrid'].includes(antennaType) && trapFreqCount === 0) {
                addTrapFrequency();
            }
        }

        function addFanFrequency() {
            const fanFrequencies = document.getElementById('fanFrequencies');
            const freqId = `fanFreq${fanFreqCount}`;
            const div = document.createElement('div');
            div.innerHTML = `
                <label>
                    Additional Frequency ${fanFreqCount + 1} (MHz):
                    <input type="number" id="${freqId}" step="0.1" min="0.1" value="${7.1 + fanFreqCount * 7}">
                    <button class="remove-btn" onclick="removeFanFrequency(this)">Remove</button>
                </label>
            `;
            fanFrequencies.appendChild(div);
            fanFreqCount++;
        }

        function removeFanFrequency(button) {
            if (fanFreqCount > 1) {
                button.parentElement.parentElement.remove();
                fanFreqCount--;
            }
        }

        function addHybridElement() {
            const hybridElements = document.getElementById('hybridElements');
            const elementId = `hybridElement${hybridElementCount}`;
            const div = document.createElement('div');
            div.className = 'element-container';
            div.innerHTML = `
                <label>
                    Frequency ${hybridElementCount + 1} (MHz):
                    <input type="number" id="${elementId}Freq" step="0.1" min="0.1" value="${14.2 - hybridElementCount * 7}">
                </label>
                <label>
                    Type:
                    <select id="${elementId}Type">
                        <option value="dipole">Half-Wave Dipole</option>
                        <option value="quarterVertical">Quarter-Wave Vertical</option>
                        <option value="foldedDipole">Folded Dipole</option>
                    </select>
                </label>
                <button class="remove-btn" onclick="removeHybridElement(this)">Remove</button>
            `;
            hybridElements.appendChild(div);
            hybridElementCount++;
        }

        function removeHybridElement(button) {
            if (hybridElementCount > 1) {
                button.parentElement.remove();
                hybridElementCount--;
            }
        }

        function addTrapFrequency() {
            const trapFrequencies = document.getElementById('trapFrequencies');
            const freqId = `trapFreq${trapFreqCount}`;
            const div = document.createElement('div');
            div.innerHTML = `
                <label>
                    Trap Frequency ${trapFreqCount + 1} (MHz):
                    <input type="number" id="${freqId}" step="0.1" min="0.1" value="${14.2 - trapFreqCount * 7}">
                    <button class="remove-btn"

 onclick="removeTrapFrequency(this)">Remove</button>
                </label>
            `;
            trapFrequencies.appendChild(div);
            trapFreqCount++;
        }

        function removeTrapFrequency(button) {
            if (trapFreqCount > 1) {
                button.parentElement.remove();
                trapFreqCount--;
            }
        }

        function drawAntenna(antennaType, lengths, frequencies, types, velocityFactor, useBalun, balunRatio, useTraps, trapFrequencies) {
            const canvas = document.getElementById('antennaCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const centerX = canvas.width / 2;
            const baseY = canvas.height - 50; // Move base down for better label space
            const maxLength = Math.max(...lengths);
            const scale = Math.min(15, (canvas.width - 80) / (maxLength * 2)); // Adjusted for tighter fit
            const cutGap = 8;

            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1.5;
            ctx.font = '9px Arial'; // Even smaller font
            ctx.textAlign = 'center';

            function drawFeedPoint(x, y) {
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, 2 * Math.PI);
                ctx.fillStyle = '#FF0000';
                ctx.fill();
                ctx.fillStyle = '#000';
                ctx.fillText('F', x, y + 12); // Minimal label, below
            }

            function drawGroundPlane(x, y, length) {
                ctx.strokeStyle = '#666';
                ctx.beginPath();
                ctx.moveTo(x - length * scale, y);
                ctx.lineTo(x + length * scale, y);
                ctx.stroke();
                ctx.strokeStyle = '#000';
                ctx.fillText('G', x, y + 12); // Minimal label
            }

            function drawBalun(x, y, ratio) {
                ctx.fillStyle = '#00F';
                ctx.fillRect(x - 6, y - 3, 12, 6); // Smaller balun
                ctx.fillStyle = '#000';
                ctx.fillText(ratio, x, y - 10); // Ratio above, closer
            }

            function drawTrap(x, y, freq) {
                ctx.fillStyle = '#0F0';
                ctx.fillRect(x - 3, y - 3, 6, 6); // Smaller trap
                ctx.fillStyle = '#000';
                ctx.fillText(freq.toFixed(1), x, y + 12); // Below trap
            }

            if (antennaType === 'dipole') {
                const length = lengths[0] / 2;
                const y = baseY / 2;
                ctx.beginPath();
                ctx.moveTo(centerX - length * scale, y);
                ctx.lineTo(centerX - cutGap / 2, y);
                ctx.moveTo(centerX + cutGap / 2, y);
                ctx.lineTo(centerX + length * scale, y);
                ctx.stroke();
                drawFeedPoint(centerX, y);
                if (useBalun && balunRatio) drawBalun(centerX, y, balunRatio);
                ctx.fillText(`${length.toFixed(2)}`, centerX - length * scale / 2, y - 10);
                ctx.fillText(`${length.toFixed(2)}`, centerX + length * scale / 2, y - 10);
            } else if (antennaType === 'quarterVertical') {
                const length = lengths[0];
                ctx.beginPath();
                ctx.moveTo(centerX, baseY);
                ctx.lineTo(centerX, baseY - length * scale);
                ctx.stroke();
                drawFeedPoint(centerX, baseY);
                if (useBalun && balunRatio) drawBalun(centerX, baseY, balunRatio);
                drawGroundPlane(centerX, baseY, length);
                ctx.textAlign = 'left';
                ctx.fillText(`${length.toFixed(2)}`, centerX + 5, baseY - length * scale / 2);
                ctx.textAlign = 'center';
            } else if (antennaType === 'foldedDipole') {
                const length = lengths[0] / 2;
                const height = 12;
                const y = baseY / 2;
                ctx.beginPath();
                ctx.moveTo(centerX - length * scale, y - height);
                ctx.lineTo(centerX - cutGap / 2, y - height);
                ctx.moveTo(centerX + cutGap / 2, y - height);
                ctx.lineTo(centerX + length * scale, y - height);
                ctx.lineTo(centerX + length * scale, y + height);
                ctx.lineTo(centerX - length * scale, y + height);
                ctx.lineTo(centerX - length * scale, y - height);
                ctx.stroke();
                drawFeedPoint(centerX, y - height);
                if (useBalun && balunRatio) drawBalun(centerX, y - height, balunRatio);
                ctx.fillText(`${length.toFixed(2)}`, centerX - length * scale / 2, y - height - 10);
                ctx.fillText(`${length.toFixed(2)}`, centerX + length * scale / 2, y - height - 10);
            } else if (antennaType === 'endFed') {
                const length = lengths[0];
                const y = baseY / 2;
                ctx.beginPath();
                ctx.moveTo(centerX - length * scale, y);
                ctx.lineTo(centerX, y);
                ctx.stroke();
                drawFeedPoint(centerX - length * scale, y);
                if (useBalun && balunRatio) drawBalun(centerX - length * scale, y, balunRatio);
                ctx.fillText(`${length.toFixed(2)}`, centerX - length * scale / 2, y - 10);
            } else if (antennaType === 'fanDipole' || antennaType === 'hybrid') {
                const elementHeight = Math.min(40, (baseY - 50) / lengths.length); // Dynamic spacing
                const totalHeight = (lengths.length - 1) * elementHeight;
                const startY = (baseY - totalHeight) / 2;
                let trapIndex = 0;
                lengths.forEach((length, index) => {
                    const yOffset = startY + index * elementHeight;
                    const elementType = types[index];
                    if (elementType === 'dipole') {
                        const halfLength = length / 2;
                        ctx.beginPath();
                        ctx.moveTo(centerX - halfLength * scale, yOffset);
                        ctx.lineTo(centerX - cutGap / 2, yOffset);
                        ctx.moveTo(centerX + cutGap / 2, yOffset);
                        ctx.lineTo(centerX + halfLength * scale, yOffset);
                        ctx.stroke();
                        if (index === 0) drawFeedPoint(centerX, yOffset);
                        if (useBalun && balunRatio && index === 0) drawBalun(centerX, yOffset, balunRatio);
                        if (useTraps && trapIndex < trapFrequencies.length && index > 0) {
                            const trapSpacing = halfLength / 2;
                            drawTrap(centerX - trapSpacing * scale, yOffset, trapFrequencies[trapIndex]);
                            drawTrap(centerX + trapSpacing * scale, yOffset, trapFrequencies[trapIndex]);
                            trapIndex++;
                        }
                        ctx.fillText(`${halfLength.toFixed(2)}`, centerX - halfLength * scale / 2, yOffset - 10);
                        ctx.fillText(`${halfLength.toFixed(2)}`, centerX + halfLength * scale / 2, yOffset - 10);
                        ctx.textAlign = 'left';
                        ctx.fillText(`${frequencies[index].toFixed(1)} MHz`, centerX + halfLength * scale + 5, yOffset);
                        ctx.textAlign = 'center';
                    } else if (elementType === 'quarterVertical') {
                        ctx.beginPath();
                        ctx.moveTo(centerX, yOffset);
                        ctx.lineTo(centerX, yOffset - length * scale);
                        ctx.stroke();
                        if (index === 0) drawFeedPoint(centerX, yOffset);
                        if (useBalun && balunRatio && index === 0) drawBalun(centerX, yOffset, balunRatio);
                        drawGroundPlane(centerX, yOffset, length);
                        ctx.textAlign = 'left';
                        ctx.fillText(`${length.toFixed(2)} (${frequencies[index].toFixed(1)} MHz)`, 
                            centerX + 5, yOffset - length * scale / 2);
                        ctx.textAlign = 'center';
                    } else if (elementType === 'foldedDipole') {
                        const halfLength = length / 2;
                        const height = 12;
                        ctx.beginPath();
                        ctx.moveTo(centerX - halfLength * scale, yOffset - height);
                        ctx.lineTo(centerX - cutGap / 2, yOffset - height);
                        ctx.moveTo(centerX + cutGap / 2, yOffset - height);
                        ctx.lineTo(centerX + halfLength * scale, yOffset - height);
                        ctx.lineTo(centerX + halfLength * scale, yOffset + height);
                        ctx.lineTo(centerX - halfLength * scale, yOffset + height);
                        ctx.lineTo(centerX - halfLength * scale, yOffset - height);
                        ctx.stroke();
                        if (index === 0) drawFeedPoint(centerX, yOffset - height);
                        if (useBalun && balunRatio && index === 0) drawBalun(centerX, yOffset - height, balunRatio);
                        if (useTraps && trapIndex < trapFrequencies.length && index > 0) {
                            const trapSpacing = halfLength / 2;
                            drawTrap(centerX - trapSpacing * scale, yOffset, trapFrequencies[trapIndex]);
                            drawTrap(centerX + trapSpacing * scale, yOffset, trapFrequencies[trapIndex]);
                            trapIndex++;
                        }
                        ctx.fillText(`${halfLength.toFixed(2)}`, centerX - halfLength * scale / 2, yOffset - height - 10);
                        ctx.fillText(`${halfLength.toFixed(2)}`, centerX + halfLength * scale / 2, yOffset - height - 10);
                        ctx.textAlign = 'left';
                        ctx.fillText(`${frequencies[index].toFixed(1)} MHz`, centerX + halfLength * scale + 5, yOffset);
                        ctx.textAlign = 'center';
                    }
                });
            }
        }

        function calculateAntenna() {
            const frequency = parseFloat(document.getElementById('frequency').value);
            const antennaType = document.getElementById('antennaType').value;
            let velocityFactor = parseFloat(document.getElementById('velocityFactor').value);
            const wireMaterial = document.getElementById('wireMaterial').value;
            const wireGauge = parseInt(document.getElementById('wireGauge').value);
            const useBalun = document.getElementById('useBalun').checked;
            const useTraps = document.getElementById('useTraps').checked && ['fanDipole', 'hybrid'].includes(antennaType);

            const materialVF = {
                'copper': 0.95,
                'aluminum': 0.93,
                'insulated': 0.90
            };
            if (velocityFactor === 0.95 && wireMaterial !== 'copper') {
                velocityFactor = materialVF[wireMaterial];
            }

            if (isNaN(frequency) || frequency <= 0) {
                alert('Please enter a valid primary frequency');
                return;
            }
            if (isNaN(velocityFactor) || velocityFactor <= 0 || velocityFactor > 1) {
                alert('Please enter a valid velocity factor between 0 and 1');
                return;
            }
            if (wireGauge < 6 || wireGauge > 30) {
                alert('Wire gauge should be between 6 and 30 AWG');
                return;
            }

            let trapFrequencies = [];
            if (useTraps) {
                for (let i = 0; i < trapFreqCount; i++) {
                    const freq = parseFloat(document.getElementById(`trapFreq${i}`).value);
                    if (isNaN(freq) || freq <= 0) {
                        alert(`Please enter a valid trap frequency for trap ${i + 1}`);
                        return;
                    }
                    trapFrequencies.push(freq);
                }
            }

            const speedOfLight = 299792458; // meters per second
            const wavelength = speedOfLight / (frequency * 1000000);
            let results = [];
            let calcResults = [];
            let lengths = [];
            let frequencies = [];
            let types = [];

            function formatLength(length) {
                const feet = length * 3.28084;
                const inches = feet * 12;
                return `${length.toFixed(2)} m (${feet.toFixed(2)} ft, ${inches.toFixed(2)} in)`;
            }

            function estimateSWR(length, freq, type) {
                const idealLength = type === 'quarterVertical' ? 
                    (speedOfLight / (freq * 1000000)) * 0.25 * velocityFactor :
                    (speedOfLight / (freq * 1000000)) * 0.5 * velocityFactor;
                const deviation = Math.abs(length - idealLength) / idealLength;
                return Math.max(1, 1 + deviation * 10).toFixed(1);
            }

            function determineBalunRatio(type) {
                if (!useBalun) return null;
                switch (type) {
                    case 'endFed':
                        return '49:1'; // ~2500-3000Ω to 50Ω
                    case 'foldedDipole':
                        return '4:1'; // 300Ω to 75Ω
                    case 'dipole':
                    case 'quarterVertical':
                    case 'fanDipole':
                    case 'hybrid':
                        return '1:1'; // ~50-75Ω balanced to 50Ω coax
                    default:
                        return null;
                }
            }

            const balunRatio = determineBalunRatio(antennaType);

            // Calculations Section
            calcResults.push(`<b>Fundamental Constants:</b>`);
            calcResults.push(`- Speed of Light (c): ${speedOfLight} m/s - The speed at which electromagnetic waves propagate in a vacuum.`);
            calcResults.push(`- Velocity Factor (VF): ${velocityFactor} - Accounts for the slower propagation speed in the wire due to material properties (e.g., ${wireMaterial}).`);

            calcResults.push(`<b>Design Parameters:</b>`);
            calcResults.push(`- Antenna Type: ${antennaType}`);
            calcResults.push(`- Wire Material: ${wireMaterial} - Impacts VF and durability.`);
            calcResults.push(`- Wire Gauge: ${wireGauge} AWG - Affects current capacity and strength.`);

            if (balunRatio) {
                calcResults.push(`- Balun/UnUn: ${balunRatio} - Chosen to match impedance:`);
                if (antennaType === 'endFed') calcResults.push(`  - End-fed half-wave has ~2500-3000Ω impedance; 49:1 transforms to ~50Ω for coax.`);
                if (antennaType === 'foldedDipole') calcResults.push(`  - Folded dipole has ~300Ω; 4:1 transforms to ~75Ω, close to 50Ω coax.`);
                if (['dipole', 'quarterVertical', 'fanDipole', 'hybrid'].includes(antennaType)) 
                    calcResults.push(`  - Impedance ~50-75Ω; 1:1 ensures balanced-to-unbalanced transition.`);
            }

            if (antennaType === 'dipole') {
                const length = wavelength * 0.5 * velocityFactor;
                lengths.push(length);
                frequencies.push(frequency);
                types.push('dipole');
                results.push(`Half-Wave Dipole:`);
                results.push(`- Total Length: ${formatLength(length)}`);
                results.push(`- Each Leg: ${formatLength(length / 2)}`);
                if (balunRatio) results.push(`- Balun (${balunRatio}): At center feedpoint`);
                results.push(`- SWR at ${frequency} MHz: ${estimateSWR(length, frequency, 'dipole')}`);

                calcResults.push(`<b>Element 1: Half-Wave Dipole at ${frequency} MHz</b>`);
                calcResults.push(`- Wavelength (λ) = c / f = ${speedOfLight} / (${frequency} × 10⁶) = ${(speedOfLight / (frequency * 1000000)).toFixed(2)} m`);
                calcResults.push(`- Reasoning: A half-wave dipole is resonant when its total length is λ/2, adjusted by VF for the wire's propagation speed.`);
                calcResults.push(`- Total Length = λ × 0.5 × VF = ${(speedOfLight / (frequency * 1000000)).toFixed(2)} × 0.5 × ${velocityFactor} = ${length.toFixed(2)} m`);
                calcResults.push(`- SWR = max(1, 1 + |actual - ideal| / ideal × 10) = max(1, 1 + |${length.toFixed(2)} - ${length.toFixed(2)}| / ${length.toFixed(2)} × 10) = ${estimateSWR(length, frequency, 'dipole')}`);
                calcResults.push(`  - SWR is 1.0 at resonance; increases with frequency deviation.`);
            } else if (antennaType === 'quarterVertical') {
                const length = wavelength * 0.25 * velocityFactor;
                lengths.push(length);
                frequencies.push(frequency);
                types.push('quarterVertical');
                results.push(`Quarter-Wave Vertical:`);
                results.push(`- Radiator: ${formatLength(length)}`);
                results.push(`- Radial Length: ${formatLength(length)} (suggested)`);
                if (balunRatio) results.push(`- Balun (${balunRatio}): At base feedpoint`);
                results.push(`- SWR at ${frequency} MHz: ${estimateSWR(length * 2, frequency, 'quarterVertical')}`);

                calcResults.push(`<b>Element 1: Quarter-Wave Vertical at ${frequency} MHz</b>`);
                calcResults.push(`- Wavelength (λ) = c / f = ${speedOfLight} / (${frequency} × 10⁶) = ${(speedOfLight / (frequency * 1000000)).toFixed(2)} m`);
                calcResults.push(`- Reasoning: A quarter-wave vertical is λ/4 tall, with a ground plane mimicking the other half for resonance.`);
                calcResults.push(`- Radiator Length = λ × 0.25 × VF = ${(speedOfLight / (frequency * 1000000)).toFixed(2)} × 0.25 × ${velocityFactor} = ${length.toFixed(2)} m`);
                calcResults.push(`- SWR (effective dipole length) = max(1, 1 + |${(length * 2).toFixed(2)} - ${(speedOfLight / (frequency * 1000000) * 0.5 * velocityFactor).toFixed(2)}| / ${(speedOfLight / (frequency * 1000000) * 0.5 * velocityFactor).toFixed(2)} × 10) = ${estimateSWR(length * 2, frequency, 'quarterVertical')}`);
                calcResults.push(`  - SWR assumes ground plane completes the half-wave pattern.`);
            } else if (antennaType === 'foldedDipole') {
                const length = wavelength * 0.5 * velocityFactor;
                const spacing = 0.02;
                lengths.push(length);
                frequencies.push(frequency);
                types.push('foldedDipole');
                results.push(`Folded Dipole:`);
                results.push(`- Total Wire Length: ${formatLength(length * 2)}`);
                results.push(`- Each Side: ${formatLength(length)}`);
                results.push(`- Spacing: ${formatLength(spacing)}`);
                if (balunRatio) results.push(`- Balun (${balunRatio}): At top center feedpoint`);
                results.push(`- SWR at ${frequency} MHz: ${estimateSWR(length, frequency, 'foldedDipole')} (impedance ~300Ω)`);

                calcResults.push(`<b>Element 1: Folded Dipole at ${frequency} MHz</b>`);
                calcResults.push(`- Wavelength (λ) = c / f = ${speedOfLight} / (${frequency} × 10⁶) = ${(speedOfLight / (frequency * 1000000)).toFixed(2)} m`);
                calcResults.push(`- Reasoning: A folded dipole is a half-wave loop, doubling wire length for higher impedance (~300Ω).`);
                calcResults.push(`- Side Length = λ × 0.5 × VF = ${(speedOfLight / (frequency * 1000000)).toFixed(2)} × 0.5 × ${velocityFactor} = ${length.toFixed(2)} m`);
                calcResults.push(`- Total Wire = 2 × ${length.toFixed(2)} = ${(length * 2).toFixed(2)} m`);
                calcResults.push(`- SWR = max(1, 1 + |${length.toFixed(2)} - ${length.toFixed(2)}| / ${length.toFixed(2)} × 10) = ${estimateSWR(length, frequency, 'foldedDipole')}`);
                calcResults.push(`  - SWR assumes proper balun matching to 50Ω coax.`);
            } else if (antennaType === 'endFed') {
                const length = wavelength * 0.5 * velocityFactor;
                lengths.push(length);
                frequencies.push(frequency);
                types.push('endFed');
                results.push(`End-Fed Wire:`);
                results.push(`- Total Length: ${formatLength(length)}`);
                if (balunRatio) results.push(`- UnUn (${balunRatio}): At end feedpoint`);
                results.push(`- SWR at ${frequency} MHz: ${estimateSWR(length, frequency, 'endFed')} (impedance ~2500-3000Ω)`);

                calcResults.push(`<b>Element 1: End-Fed Wire at ${frequency} MHz</b>`);
                calcResults.push(`- Wavelength (λ) = c / f = ${speedOfLight} / (${frequency} × 10⁶) = ${(speedOfLight / (frequency * 1000000)).toFixed(2)} m`);
                calcResults.push(`- Reasoning: A half-wave end-fed is resonant at λ/2, with high impedance at the end requiring a 49:1 UnUn.`);
                calcResults.push(`- Total Length = λ × 0.5 × VF = ${(speedOfLight / (frequency * 1000000)).toFixed(2)} × 0.5 × ${velocityFactor} = ${length.toFixed(2)} m`);
                calcResults.push(`- SWR = max(1, 1 + |${length.toFixed(2)} - ${length.toFixed(2)}| / ${length.toFixed(2)} × 10) = ${estimateSWR(length, frequency, 'endFed')}`);
                calcResults.push(`  - SWR assumes 49:1 UnUn matches ~2500Ω to 50Ω coax.`);
            } else if (antennaType === 'fanDipole') {
                const fanFrequencies = [];
                fanFrequencies.push(frequency);
                for (let i = 0; i < fanFreqCount; i++) {
                    const freq = parseFloat(document.getElementById(`fanFreq${i}`).value);
                    if (isNaN(freq) || freq <= 0) {
                        alert(`Please enter a valid frequency for element ${i + 1}`);
                        return;
                    }
                    fanFrequencies.push(freq);
                }

                results.push(`Fan Dipole:`);
                calcResults.push(`<b>Fan Dipole Elements:</b>`);
                fanFrequencies.forEach((freq, index) => {
                    const length = (speedOfLight / (freq * 1000000)) * 0.5 * velocityFactor;
                    lengths.push(length);
                    frequencies.push(freq);
                    types.push('dipole');
                    results.push(`- ${freq} MHz: ${formatLength(length)}`);
                    if (useTraps && trapFrequencies.length > 0 && index > 0 && index <= trapFrequencies.length) {
                        results.push(`  - Traps (${trapFrequencies[index - 1]} MHz): At ~1/4 length from feedpoint`);
                    }
                    fanFrequencies.forEach(testFreq => {
                        results.push(`  - SWR at ${testFreq} MHz: ${estimateSWR(length, testFreq, 'dipole')}`);
                    });

                    calcResults.push(`Element ${index + 1}: Dipole at ${freq} MHz`);
                    calcResults.push(`- Wavelength (λ) = c / f = ${speedOfLight} / (${freq} × 10⁶) = ${(speedOfLight / (freq * 1000000)).toFixed(2)} m`);
                    calcResults.push(`- Reasoning: Each dipole is λ/2 for its frequency, sharing a common feedpoint.`);
                    calcResults.push(`- Total Length = λ × 0.5 × VF = ${(speedOfLight / (freq * 1000000)).toFixed(2)} × 0.5 × ${velocityFactor} = ${length.toFixed(2)} m`);
                    calcResults.push(`- SWR at ${freq} MHz = max(1, 1 + |${length.toFixed(2)} - ${(speedOfLight / (freq * 1000000) * 0.5 * velocityFactor).toFixed(2)}| / ${(speedOfLight / (freq * 1000000) * 0.5 * velocityFactor).toFixed(2)} × 10) = ${estimateSWR(length, freq, 'dipole')}`);
                    if (useTraps && index > 0 && index <= trapFrequencies.length) {
                        calcResults.push(`  - Trap at ${trapFrequencies[index - 1]} MHz isolates this element from lower frequencies.`);
                    }
                });
                if (balunRatio) results.push(`- Balun (${balunRatio}): At common center feedpoint`);
            } else if (antennaType === 'hybrid') {
                const hybridFrequencies = [];
                const hybridTypes = [];
                hybridFrequencies.push(frequency);
                hybridTypes.push(document.getElementById(`hybridElement0Type`).value);
                for (let i = 1; i < hybridElementCount; i++) {
                    const freq = parseFloat(document.getElementById(`hybridElement${i}Freq`).value);
                    const type = document.getElementById(`hybridElement${i}Type`).value;
                    if (isNaN(freq) || freq <= 0) {
                        alert(`Please enter a valid frequency for element ${i + 1}`);
                        return;
                    }
                    hybridFrequencies.push(freq);
                    hybridTypes.push(type);
                }

                results.push(`Hybrid Antenna:`);
                calcResults.push(`<b>Hybrid Elements:</b>`);
                hybridFrequencies.forEach((freq, index) => {
                    const type = hybridTypes[index];
                    const length = type === 'quarterVertical' ? 
                        (speedOfLight / (freq * 1000000)) * 0.25 * velocityFactor :
                        (speedOfLight / (freq * 1000000)) * 0.5 * velocityFactor;
                    const spacing = type === 'foldedDipole' ? 0.02 : 0;
                    lengths.push(length);
                    frequencies.push(freq);
                    types.push(type);
                    if (type === 'dipole') {
                        results.push(`- Dipole at ${freq} MHz: ${formatLength(length)}`);
                        results.push(`  - Each Leg: ${formatLength(length / 2)}`);
                        if (useTraps && trapFrequencies.length > 0 && index > 0 && index <= trapFrequencies.length) {
                            results.push(`  - Traps (${trapFrequencies[index - 1]} MHz): At ~1/4 length from feedpoint`);
                        }
                        calcResults.push(`Element ${index + 1}: Dipole at ${freq} MHz`);
                        calcResults.push(`- Wavelength (λ) = c / f = ${speedOfLight} / (${freq} × 10⁶) = ${(speedOfLight / (freq * 1000000)).toFixed(2)} m`);
                        calcResults.push(`- Total Length = λ × 0.5 × VF = ${(speedOfLight / (freq * 1000000)).toFixed(2)} × 0.5 × ${velocityFactor} = ${length.toFixed(2)} m`);
                        calcResults.push(`- SWR at ${freq} MHz = ${estimateSWR(length, freq, 'dipole')}`);
                    } else if (type === 'quarterVertical') {
                        results.push(`- Vertical at ${freq} MHz: ${formatLength(length)}`);
                        results.push(`  - Ground Plane: ${formatLength(length)}`);
                        calcResults.push(`Element ${index + 1}: Quarter-Wave Vertical at ${freq} MHz`);
                        calcResults.push(`- Wavelength (λ) = c / f = ${speedOfLight} / (${freq} × 10⁶) = ${(speedOfLight / (freq * 1000000)).toFixed(2)} m`);
                        calcResults.push(`- Radiator Length = λ × 0.25 × VF = ${(speedOfLight / (freq * 1000000)).toFixed(2)} × 0.25 × ${velocityFactor} = ${length.toFixed(2)} m`);
                        calcResults.push(`- SWR at ${freq} MHz = ${estimateSWR(length * 2, freq, 'quarterVertical')}`);
                    } else if (type === 'foldedDipole') {
                        results.push(`- Folded Dipole at ${freq} MHz: ${formatLength(length * 2)}`);
                        results.push(`  - Each Side: ${formatLength(length)}`);
                        results.push(`  - Spacing: ${formatLength(spacing)}`);
                        if (useTraps && trapFrequencies.length > 0 && index > 0 && index <= trapFrequencies.length) {
                            results.push(`  - Traps (${trapFrequencies[index - 1]} MHz): At ~1/4 length from feedpoint`);
                        }
                        calcResults.push(`Element ${index + 1}: Folded Dipole at ${freq} MHz`);
                        calcResults.push(`- Wavelength (λ) = c / f = ${speedOfLight} / (${freq} × 10⁶) = ${(speedOfLight / (freq * 1000000)).toFixed(2)} m`);
                        calcResults.push(`- Side Length = λ × 0.5 × VF = ${(speedOfLight / (freq * 1000000)).toFixed(2)} × 0.5 × ${velocityFactor} = ${length.toFixed(2)} m`);
                        calcResults.push(`- Total Wire = 2 × ${length.toFixed(2)} = ${(length * 2).toFixed(2)} m`);
                        calcResults.push(`- SWR at ${freq} MHz = ${estimateSWR(length, freq, 'foldedDipole')}`);
                    }
                    hybridFrequencies.forEach(testFreq => {
                        results.push(`  - SWR at ${testFreq} MHz: ${estimateSWR(length, testFreq, type)}`);
                    });
                    calcResults.push(`- Reasoning: ${type === 'quarterVertical' ? 'Quarter-wave with ground plane' : type === 'foldedDipole' ? 'Half-wave folded for higher impedance' : 'Half-wave dipole'} for resonance at ${freq} MHz.`);
                    if (useTraps && index > 0 && index <= trapFrequencies.length) {
                        calcResults.push(`  - Trap at ${trapFrequencies[index - 1]} MHz isolates this element.`);
                    }
                });
                if (balunRatio) results.push(`- Balun (${balunRatio}): At common feedpoint`);
            }

            document.getElementById('resultText').innerHTML = results.join('<br>');
            document.getElementById('calculationText').innerHTML = calcResults.join('<br>');
            drawAntenna(antennaType, lengths, frequencies, types, velocityFactor, useBalun, balunRatio, useTraps, trapFrequencies);

            document.getElementById('defaultOpen').click();
        }

        function openTab(evt, tabName) {
            const tabcontent = document.getElementsByClassName('tabcontent');
            for (let i = 0; i < tabcontent.length; i++) {
                tabcontent[i].style.display = 'none';
            }
            const tablinks = document.getElementsByClassName('tablinks');
            for (let i = 0; i < tablinks.length; i++) {
                tablinks[i].className = tablinks[i].className.replace(' active', '');
            }
            document.getElementById(tabName).style.display = 'block';
            evt.currentTarget.className += ' active';
        }
    </script>
</body>
</html>
