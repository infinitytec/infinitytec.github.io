<!-- This is an experemental antenna calculation tool written largely by Generative AI. Use at your own risk. As this is written by Generative AI, I am disavowing any copyright on it. -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Experimental Antenna Calculator</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 900px;
            margin: 20px auto;
            padding: 20px;
        }
        .section {
            margin-bottom: 20px;
        }
        label {
            display: block;
            margin: 5px 0;
        }
        button {
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
        }
        button:hover {
            background-color: #45a049;
        }
        #results {
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #ddd;
        }
        .hidden {
            display: none;
        }
        .remove-btn {
            background-color: #f44336;
            margin-left: 10px;
            padding: 5px 10px;
        }
        .remove-btn:hover {
            background-color: #da190b;
        }
        #antennaCanvas, #swrCanvas {
            border: 1px solid #000;
            margin-top: 20px;
        }
        .element-container {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        .tab {
            overflow: hidden;
            border: 1px solid #ccc;
            background-color: #f1f1f1;
        }
        .tab button {
            background-color: inherit;
            float: left;
            border: none;
            outline: none;
            cursor: pointer;
            padding: 14px 16px;
            transition: 0.3s;
        }
        .tab button:hover {
            background-color: #ddd;
        }
        .tab button.active {
            background-color: #ccc;
        }
        .tabcontent {
            display: none;
            padding: 6px 12px;
            border: 1px solid #ccc;
            border-top: none;
        }
    </style>
</head>
<body>
    <h1>Experimental Antenna Calculator</h1>
    <p>This is an experemental antenna calculation tool written largely by Generative AI. Use at your own risk.</p>
    <div class="section">
        <h2>Input Parameters</h2>
        <div id="targetBands">
            <h3>Target Bands (MHz)</h3>
            <div id="bandFrequencies"></div>
            <button onclick="addBandFrequency()">Add Band</button>
        </div>
        <label>
            Antenna Type:
            <select id="antennaType" onchange="toggleAdvancedOptions()">
                <option value="dipole">Half-Wave Dipole</option>
                <option value="quarterVertical">Quarter-Wave Vertical</option>
                <option value="foldedDipole">Folded Dipole</option>
                <option value="fanDipole">Fan Dipole</option>
                <option value="hybrid">Hybrid (Custom Elements)</option>
                <option value="endFed">End-Fed Wire</option>
                <option value="randomWire">Random Wire</option>
                <option value="offCenterDipole">Off-Center Fed Dipole</option>
            </select>
        </label>
        <label>
            Velocity Factor (0-1, default 0.95 for bare wire):
            <input type="number" id="velocityFactor" step="0.01" min="0" max="1" value="0.95">
        </label>
        <label>
            Wire Material:
            <select id="wireMaterial">
                <option value="copper">Copper (VF: 0.95)</option>
                <option value="aluminum">Aluminum (VF: 0.93)</option>
                <option value="insulated">Insulated Copper (VF: 0.90)</option>
            </select>
        </label>
        <label>
            Wire Gauge (AWG):
            <input type="number" id="wireGauge" min="6" max="30" value="14">
        </label>
        <label>
            Use Balun/UnUn:
            <input type="checkbox" id="useBalun">
        </label>
        <label>
            Use Traps (for multi-band):
            <input type="checkbox" id="useTraps" onchange="toggleTrapOptions()">
        </label>
        <div id="trapOptions" class="hidden">
            <h3>Trap Frequencies (Auto-Calculated)</h3>
            <p>Trap frequencies will be automatically determined based on the antenna design.</p>
        </div>

        <div id="randomWireOptions" class="hidden">
            <label>
                Wire Length (meters):
                <input type="number" id="randomWireLength" step="0.1" min="1" value="10">
            </label>
        </div>

        <div id="fanDipoleOptions" class="hidden">
            <p>Note: Use Target Bands for Fan Dipole frequencies.</p>
        </div>

        <div id="hybridOptions" class="hidden">
            <h3>Hybrid Elements</h3>
            <div id="hybridElements"></div>
            <button onclick="addHybridElement()">Add Element</button>
        </div>

        <button onclick="calculateAntenna()">Calculate</button>
    </div>

    <div id="results">
        <h2>Results</h2>
        <div class="tab">
            <button class="tablinks" onclick="openTab(event, 'Design')" id="defaultOpen">Design</button>
            <button class="tablinks" onclick="openTab(event, 'Calculations')">Calculations</button>
            <button class="tablinks" onclick="openTab(event, 'TrapDesign')">Trap Design</button>
            <button class="tablinks" onclick="openTab(event, 'SWRPlot')">SWR Plot</button>
        </div>

        <div id="Design" class="tabcontent">
            <p id="resultText">Enter parameters and click Calculate to see results.</p>
            <canvas id="antennaCanvas" width="600" height="400"></canvas>
        </div>

        <div id="Calculations" class="tabcontent">
            <p id="calculationText">Calculations will appear here after clicking Calculate.</p>
        </div>

        <div id="TrapDesign" class="tabcontent">
            <p id="trapDesignText">Trap designs will appear here if traps are used.</p>
        </div>

        <div id="SWRPlot" class="tabcontent">
            <p id="swrPlotText">SWR plot will appear here after calculation.</p>
            <canvas id="swrCanvas" width="600" height="400"></canvas>
        </div>
    </div>

    <script>
        let bandFreqCount = 0;
        let hybridElementCount = 0;
        const suggestedFrequencies = [0.135, 0.472, 1.8, 3.5, 5.3, 7, 10.1, 14, 18, 21, 28, 50, 144, 222, 420, 902, 1240];

        function addBandFrequency() {
            const bandFrequencies = document.getElementById('bandFrequencies');
            const freqId = `bandFreq${bandFreqCount}`;
            const div = document.createElement('div');
            div.innerHTML = `
                <label>
                    Band ${bandFreqCount + 1} (MHz):
                    <input type="number" id="${freqId}" step="0.001" min="0.1" value="${bandFreqCount === 0 ? 14 : suggestedFrequencies[bandFreqCount % suggestedFrequencies.length]}">
                    <button class="remove-btn" onclick="removeBandFrequency(this)">Remove</button>
                </label>
            `;
            bandFrequencies.appendChild(div);
            bandFreqCount++;
        }

        function removeBandFrequency(button) {
            if (bandFreqCount > 1) {
                button.parentElement.parentElement.remove();
                bandFreqCount--;
            }
        }

        function toggleAdvancedOptions() {
            const antennaType = document.getElementById('antennaType').value;
            document.getElementById('fanDipoleOptions').classList.toggle('hidden', antennaType !== 'fanDipole');
            document.getElementById('hybridOptions').classList.toggle('hidden', antennaType !== 'hybrid');
            document.getElementById('randomWireOptions').classList.toggle('hidden', antennaType !== 'randomWire');
            if (antennaType === 'hybrid' && hybridElementCount === 0) {
                addHybridElement();
            }
            toggleTrapOptions();
        }

        function toggleTrapOptions() {
            const useTraps = document.getElementById('useTraps').checked;
            document.getElementById('trapOptions').classList.toggle('hidden', !useTraps);
        }

        function addHybridElement() {
            const hybridElements = document.getElementById('hybridElements');
            const elementId = `hybridElement${hybridElementCount}`;
            const div = document.createElement('div');
            div.className = 'element-container';
            div.innerHTML = `
                <label>
                    Type:
                    <select id="${elementId}Type">
                        <option value="dipole">Half-Wave Dipole</option>
                        <option value="quarterVertical">Quarter-Wave Vertical</option>
                        <option value="foldedDipole">Folded Dipole</option>
                    </select>
                </label>
                <button class="remove-btn" onclick="removeHybridElement(this)">Remove</button>
            `;
            hybridElements.appendChild(div);
            hybridElementCount++;
        }

        function removeHybridElement(button) {
            if (hybridElementCount > 1) {
                button.parentElement.remove();
                hybridElementCount--;
            }
        }

        function drawAntenna(antennaType, lengths, frequencies, types, velocityFactor, useBalun, balunRatio, useTraps, trapFrequencies) {
            const canvas = document.getElementById('antennaCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const centerX = canvas.width / 2;
            const baseY = canvas.height - 50;
            const maxLength = Math.max(...lengths);
            const scale = Math.min(15, (canvas.width - 80) / (maxLength * 2));
            const cutGap = 8;

            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1.5;
            ctx.font = '9px Arial';
            ctx.textAlign = 'center';

            function drawFeedPoint(x, y) {
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, 2 * Math.PI);
                ctx.fillStyle = '#FF0000';
                ctx.fill();
                ctx.fillStyle = '#000';
                ctx.fillText('F', x, y + 12);
            }

            function drawGroundPlane(x, y, length) {
                ctx.strokeStyle = '#666';
                ctx.beginPath();
                ctx.moveTo(x - length * scale, y);
                ctx.lineTo(x + length * scale, y);
                ctx.stroke();
                ctx.strokeStyle = '#000';
                ctx.fillText('G', x, y + 12);
            }

            function drawBalun(x, y, ratio) {
                ctx.fillStyle = '#00F';
                ctx.fillRect(x - 6, y - 3, 12, 6);
                ctx.fillStyle = '#000';
                ctx.fillText(ratio, x, y - 10);
            }

            function drawTrap(x, y, freq) {
                ctx.fillStyle = '#0F0';
                ctx.fillRect(x - 3, y - 3, 6, 6);
                ctx.fillStyle = '#000';
                ctx.fillText(freq.toFixed(1), x, y + 12);
            }

            if (antennaType === 'dipole' || antennaType === 'foldedDipole' || antennaType === 'endFed' || antennaType === 'offCenterDipole') {
                const length = lengths[0];
                const y = baseY / 2;
                let halfLength = length / 2;
                let feedX = centerX;
                if (antennaType === 'endFed') {
                    halfLength = length;
                    feedX = centerX - length * scale;
                } else if (antennaType === 'offCenterDipole') {
                    const shortLeg = length / 3;
                    const longLeg = length * 2 / 3;
                    feedX = centerX - shortLeg * scale;
                    ctx.beginPath();
                    ctx.moveTo(centerX - shortLeg * scale, y);
                    ctx.lineTo(centerX - shortLeg * scale - cutGap / 2, y);
                    ctx.moveTo(centerX + longLeg * scale + cutGap / 2, y);
                    ctx.lineTo(centerX + longLeg * scale, y);
                    ctx.stroke();
                    ctx.fillText(`${shortLeg.toFixed(2)}`, centerX - shortLeg * scale / 2, y - 10);
                    ctx.fillText(`${longLeg.toFixed(2)}`, centerX + longLeg * scale / 2, y - 10);
                } else {
                    ctx.beginPath();
                    ctx.moveTo(centerX - halfLength * scale, y);
                    ctx.lineTo(centerX - cutGap / 2, y);
                    ctx.moveTo(centerX + cutGap / 2, y);
                    ctx.lineTo(centerX + halfLength * scale, y);
                    ctx.stroke();
                    ctx.fillText(`${halfLength.toFixed(2)}`, centerX - halfLength * scale / 2, y - 10);
                    ctx.fillText(`${halfLength.toFixed(2)}`, centerX + halfLength * scale / 2, y - 10);
                }

                drawFeedPoint(feedX, y);
                if (useBalun && balunRatio) drawBalun(feedX, y, balunRatio);

                if (useTraps && trapFrequencies.length > 0) {
                    const trapSpacing = halfLength / (trapFrequencies.length + 1);
                    trapFrequencies.forEach((freq, index) => {
                        const trapPos = trapSpacing * (index + 1);
                        if (antennaType === 'endFed') {
                            drawTrap(centerX - length * scale + trapPos * scale, y, freq);
                        } else if (antennaType === 'offCenterDipole') {
                            const shortLeg = length / 3;
                            const longLeg = length * 2 / 3;
                            if (index < trapFrequencies.length / 2) {
                                drawTrap(centerX - shortLeg * scale + trapPos * scale, y, freq);
                            } else {
                                drawTrap(centerX + trapPos * scale, y, freq);
                            }
                        } else {
                            drawTrap(centerX - trapPos * scale, y, freq);
                            drawTrap(centerX + trapPos * scale, y, freq);
                        }
                    });
                }

                if (antennaType === 'endFed') {
                    ctx.fillText(`${length.toFixed(2)}`, centerX - length * scale / 2, y - 10);
                }
                if (antennaType === 'foldedDipole') {
                    const height = 12;
                    ctx.beginPath();
                    ctx.moveTo(centerX - halfLength * scale, y - height);
                    ctx.lineTo(centerX + halfLength * scale, y - height);
                    ctx.lineTo(centerX + halfLength * scale, y + height);
                    ctx.lineTo(centerX - halfLength * scale, y + height);
                    ctx.lineTo(centerX - halfLength * scale, y - height);
                    ctx.stroke();
                    drawFeedPoint(centerX, y - height);
                    if (useBalun && balunRatio) drawBalun(centerX, y - height, balunRatio);
                    ctx.fillText(`${halfLength.toFixed(2)}`, centerX - halfLength * scale / 2, y - height - 10);
                    ctx.fillText(`${halfLength.toFixed(2)}`, centerX + halfLength * scale / 2, y - height - 10);
                }
            } else if (antennaType === 'quarterVertical') {
                const length = lengths[0];
                ctx.beginPath();
                ctx.moveTo(centerX, baseY);
                ctx.lineTo(centerX, baseY - length * scale);
                ctx.stroke();
                drawFeedPoint(centerX, baseY);
                if (useBalun && balunRatio) drawBalun(centerX, baseY, balunRatio);
                drawGroundPlane(centerX, baseY, length);
                if (useTraps && trapFrequencies.length > 0) {
                    const trapSpacing = length / (trapFrequencies.length + 1);
                    trapFrequencies.forEach((freq, index) => {
                        drawTrap(centerX, baseY - trapSpacing * (index + 1) * scale, freq);
                    });
                }
                ctx.textAlign = 'left';
                ctx.fillText(`${length.toFixed(2)}`, centerX + 5, baseY - length * scale / 2);
                ctx.textAlign = 'center';
            } else if (antennaType === 'randomWire') {
                const length = lengths[0];
                const y = baseY / 2;
                ctx.beginPath();
                ctx.moveTo(centerX - length * scale, y);
                ctx.lineTo(centerX, y);
                ctx.stroke();
                drawFeedPoint(centerX - length * scale, y);
                if (useBalun && balunRatio) drawBalun(centerX - length * scale, y, balunRatio);
                if (useTraps && trapFrequencies.length > 0) {
                    const trapSpacing = length / (trapFrequencies.length + 1);
                    trapFrequencies.forEach((freq, index) => {
                        drawTrap(centerX - length * scale + trapSpacing * (index + 1) * scale, y, freq);
                    });
                }
                ctx.fillText(`${length.toFixed(2)}`, centerX - length * scale / 2, y - 10);
            } else if (antennaType === 'fanDipole' || antennaType === 'hybrid') {
                const elementHeight = Math.min(40, (baseY - 50) / lengths.length);
                const totalHeight = (lengths.length - 1) * elementHeight;
                const startY = (baseY - totalHeight) / 2;
                let trapIndex = 0;
                lengths.forEach((length, index) => {
                    const yOffset = startY + index * elementHeight;
                    const elementType = types[index];
                    if (elementType === 'dipole') {
                        const halfLength = length / 2;
                        ctx.beginPath();
                        ctx.moveTo(centerX - halfLength * scale, yOffset);
                        ctx.lineTo(centerX - cutGap / 2, yOffset);
                        ctx.moveTo(centerX + cutGap / 2, yOffset);
                        ctx.lineTo(centerX + halfLength * scale, yOffset);
                        ctx.stroke();
                        if (index === 0) drawFeedPoint(centerX, yOffset);
                        if (useBalun && balunRatio && index === 0) drawBalun(centerX, yOffset, balunRatio);
                        if (useTraps && trapIndex < trapFrequencies.length) {
                            const trapSpacing = halfLength / (trapFrequencies.length - trapIndex + 1);
                            for (let i = trapIndex; i < trapFrequencies.length; i++) {
                                const pos = trapSpacing * (i - trapIndex + 1);
                                drawTrap(centerX - pos * scale, yOffset, trapFrequencies[i]);
                                drawTrap(centerX + pos * scale, yOffset, trapFrequencies[i]);
                            }
                            trapIndex = trapFrequencies.length;
                        }
                        ctx.fillText(`${halfLength.toFixed(2)}`, centerX - halfLength * scale / 2, yOffset - 10);
                        ctx.fillText(`${halfLength.toFixed(2)}`, centerX + halfLength * scale / 2, yOffset - 10);
                        ctx.textAlign = 'left';
                        ctx.fillText(`${frequencies[index].toFixed(1)} MHz`, centerX + halfLength * scale + 5, yOffset);
                        ctx.textAlign = 'center';
                    } else if (elementType === 'quarterVertical') {
                        ctx.beginPath();
                        ctx.moveTo(centerX, yOffset);
                        ctx.lineTo(centerX, yOffset - length * scale);
                        ctx.stroke();
                        if (index === 0) drawFeedPoint(centerX, yOffset);
                        if (useBalun && balunRatio && index === 0) drawBalun(centerX, yOffset, balunRatio);
                        drawGroundPlane(centerX, yOffset, length);
                        if (useTraps && trapIndex < trapFrequencies.length) {
                            const trapSpacing = length / (trapFrequencies.length - trapIndex + 1);
                            for (let i = trapIndex; i < trapFrequencies.length; i++) {
                                drawTrap(centerX, yOffset - trapSpacing * (i - trapIndex + 1) * scale, trapFrequencies[i]);
                            }
                            trapIndex = trapFrequencies.length;
                        }
                        ctx.textAlign = 'left';
                        ctx.fillText(`${length.toFixed(2)} (${frequencies[index].toFixed(1)} MHz)`, 
                            centerX + 5, yOffset - length * scale / 2);
                        ctx.textAlign = 'center';
                    } else if (elementType === 'foldedDipole') {
                        const halfLength = length / 2;
                        const height = 12;
                        ctx.beginPath();
                        ctx.moveTo(centerX - halfLength * scale, yOffset - height);
                        ctx.lineTo(centerX - cutGap / 2, yOffset - height);
                        ctx.moveTo(centerX + cutGap / 2, yOffset - height);
                        ctx.lineTo(centerX + halfLength * scale, yOffset - height);
                        ctx.lineTo(centerX + halfLength * scale, yOffset + height);
                        ctx.lineTo(centerX - halfLength * scale, yOffset + height);
                        ctx.lineTo(centerX - halfLength * scale, yOffset - height);
                        ctx.stroke();
                        if (index === 0) drawFeedPoint(centerX, yOffset - height);
                        if (useBalun && balunRatio && index === 0) drawBalun(centerX, yOffset - height, balunRatio);
                        if (useTraps && trapIndex < trapFrequencies.length) {
                            const trapSpacing = halfLength / (trapFrequencies.length - trapIndex + 1);
                            for (let i = trapIndex; i < trapFrequencies.length; i++) {
                                const pos = trapSpacing * (i - trapIndex + 1);
                                drawTrap(centerX - pos * scale, yOffset, trapFrequencies[i]);
                                drawTrap(centerX + pos * scale, yOffset, trapFrequencies[i]);
                            }
                            trapIndex = trapFrequencies.length;
                        }
                        ctx.fillText(`${halfLength.toFixed(2)}`, centerX - halfLength * scale / 2, yOffset - height - 10);
                        ctx.fillText(`${halfLength.toFixed(2)}`, centerX + halfLength * scale / 2, yOffset - height - 10);
                        ctx.textAlign = 'left';
                        ctx.fillText(`${frequencies[index].toFixed(1)} MHz`, centerX + halfLength * scale + 5, yOffset);
                        ctx.textAlign = 'center';
                    }
                });
            }
        }

        function drawSWRPlot(targetBands, swrValues) {
            const canvas = document.getElementById('swrCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const margin = 50;
            const plotWidth = canvas.width - 2 * margin;
            const plotHeight = canvas.height - 2 * margin;
            const maxSWR = Math.max(...swrValues, 5); // Cap at 5 for visibility

            // Sort targetBands and swrValues together
            const sortedPairs = targetBands.map((freq, index) => [freq, swrValues[index]])
                .sort((a, b) => a[0] - b[0]);
            const sortedBands = sortedPairs.map(pair => pair[0]);
            const sortedSWR = sortedPairs.map(pair => pair[1]);

            // Grid
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 0.5;
            sortedBands.forEach((freq, index) => {
                const x = margin + (index / (sortedBands.length - 1)) * plotWidth;
                ctx.beginPath();
                ctx.moveTo(x, margin);
                ctx.lineTo(x, canvas.height - margin);
                ctx.stroke();
            });
            [1, 2, 3, 4, 5].forEach(swr => {
                const y = canvas.height - margin - (swr / maxSWR) * plotHeight;
                ctx.beginPath();
                ctx.moveTo(margin, y);
                ctx.lineTo(canvas.width - margin, y);
                ctx.stroke();
            });

            // Axes
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(margin, margin);
            ctx.lineTo(margin, canvas.height - margin);
            ctx.lineTo(canvas.width - margin, canvas.height - margin);
            ctx.stroke();

            // Labels
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Frequency (MHz)', canvas.width / 2, canvas.height - 10);
            ctx.save();
            ctx.translate(10, canvas.height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('SWR', 0, 0);
            ctx.restore();

            // Ticks and labels
            sortedBands.forEach((freq, index) => {
                const x = margin + (index / (sortedBands.length - 1)) * plotWidth;
                ctx.beginPath();
                ctx.moveTo(x, canvas.height - margin);
                ctx.lineTo(x, canvas.height - margin + 5);
                ctx.stroke();
                ctx.fillText(freq.toFixed(freq < 1 ? 3 : 1), x, canvas.height - margin + 15);
            });
            [1, 2, 3, 4, 5].forEach(swr => {
                const y = canvas.height - margin - (swr / maxSWR) * plotHeight;
                ctx.beginPath();
                ctx.moveTo(margin - 5, y);
                ctx.lineTo(margin, y);
                ctx.stroke();
                ctx.textAlign = 'right';
                ctx.fillText(swr, margin - 10, y + 5);
            });

            // Plot
            ctx.beginPath();
            ctx.strokeStyle = '#FF0000';
            ctx.lineWidth = 2;
            sortedBands.forEach((freq, index) => {
                const x = margin + (index / (sortedBands.length - 1)) * plotWidth;
                const y = canvas.height - margin - (sortedSWR[index] / maxSWR) * plotHeight;
                if (index === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            ctx.stroke();

            // Data points
            ctx.fillStyle = '#0000FF';
            sortedBands.forEach((freq, index) => {
                const x = margin + (index / (sortedBands.length - 1)) * plotWidth;
                const y = canvas.height - margin - (sortedSWR[index] / maxSWR) * plotHeight;
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, 2 * Math.PI);
                ctx.fill();
            });
        }

        function calculateAntenna() {
            const targetBands = [];
            for (let i = 0; i < bandFreqCount; i++) {
                const freq = parseFloat(document.getElementById(`bandFreq${i}`).value);
                if (isNaN(freq) || freq <= 0) {
                    alert(`Please enter a valid frequency for band ${i + 1}`);
                    return;
                }
                targetBands.push(freq);
            }
            if (targetBands.length === 0) {
                alert('Please specify at least one target band');
                return;
            }

            const antennaType = document.getElementById('antennaType').value;
            let velocityFactor = parseFloat(document.getElementById('velocityFactor').value);
            const wireMaterial = document.getElementById('wireMaterial').value;
            const wireGauge = parseInt(document.getElementById('wireGauge').value);
            const useBalun = document.getElementById('useBalun').checked;
            const useTraps = document.getElementById('useTraps').checked;

            const materialVF = {
                'copper': 0.95,
                'aluminum': 0.93,
                'insulated': 0.90
            };
            if (velocityFactor === 0.95 && wireMaterial !== 'copper') {
                velocityFactor = materialVF[wireMaterial];
            }

            if (isNaN(velocityFactor) || velocityFactor <= 0 || velocityFactor > 1) {
                alert('Please enter a valid velocity factor between 0 and 1');
                return;
            }
            if (wireGauge < 6 || wireGauge > 30) {
                alert('Wire gauge should be between 6 and 30 AWG');
                return;
            }

            const speedOfLight = 299792458; // meters per second
            let results = [];
            let calcResults = [];
            let trapResults = [];
            let lengths = [];
            let frequencies = [];
            let types = [];
            let trapFrequencies = [];
            let swrValues = [];

            function formatLength(length) {
                const feet = length * 3.28084;
                const inches = feet * 12;
                return `${length.toFixed(2)} m (${feet.toFixed(2)} ft, ${inches.toFixed(2)} in)`;
            }

            function estimateSWR(lengths, freq, type, balunRatio, traps, designFreqs) {
                // For single-element antennas, use the single length and design frequency
                const length = Array.isArray(lengths) ? lengths[0] : lengths;
                const designFreq = Array.isArray(designFreqs) ? designFreqs[0] : designFreqs;
                const isMultiElement = Array.isArray(lengths) && lengths.length > 1;

                // Base SWR from resonance
                let baseSWR = 1;
                if (isMultiElement) {
                    // Multi-element: find closest resonant frequency
                    const deviations = designFreqs.map((df, i) => {
                        const idealLength = type[i] === 'quarterVertical' ? 
                            (speedOfLight / (df * 1000000)) * 0.25 * velocityFactor :
                            (speedOfLight / (df * 1000000)) * 0.5 * velocityFactor;
                        return Math.abs(lengths[i] - idealLength) / idealLength;
                    });
                    const minDeviation = Math.min(...deviations);
                    baseSWR = 1 + minDeviation * 10;
                } else {
                    const idealLength = type === 'quarterVertical' ? 
                        (speedOfLight / (designFreq * 1000000)) * 0.25 * velocityFactor :
                        (speedOfLight / (designFreq * 1000000)) * 0.5 * velocityFactor;
                    const deviation = Math.abs(length - idealLength) / idealLength;
                    baseSWR = 1 + deviation * 10;
                }

                // Balun factor
                let balunFactor = 1;
                if (useBalun && balunRatio) {
                    const ratios = {'1:1': 1, '4:1': 4, '9:1': 9};
                    const impedanceFactor = isMultiElement ? 1 : 
                        (type === 'foldedDipole' ? 4 : 
                         (type === 'offCenterDipole' ? 4 : 
                          (type === 'endFed' || type === 'randomWire' ? 9 : 1)));
                    balunFactor = Math.abs(ratios[balunRatio] - impedanceFactor) / impedanceFactor + 1;
                }

                // Trap factor
                let trapFactor = 1;
                if (useTraps && traps.length > 0) {
                    traps.forEach(trapFreq => {
                        const freqRatio = freq / trapFreq;
                        if (freqRatio > 1) {
                            // Sharp rise above trap frequency, peaking at 10x base SWR within 5%
                            const proximity = Math.min(1, Math.max(0, (freqRatio - 1) / 0.05));
                            trapFactor += 9 * proximity; // Adds up to 9 at 5% above trap
                        }
                    });
                }

                // Resonance dips for multi-element
                let resonanceFactor = 1;
                if (isMultiElement) {
                    designFreqs.forEach(df => {
                        const freqDiff = Math.abs(freq - df) / df;
                        if (freqDiff < 0.05) {
                            // Dip towards 1 near resonant frequency
                            resonanceFactor = Math.min(resonanceFactor, 1 + (freqDiff / 0.05) * (baseSWR - 1));
                        }
                    });
                }

                return Math.max(1, baseSWR * balunFactor * trapFactor * resonanceFactor);
            }

            function determineBalunRatio(type) {
                if (!useBalun) return null;
                switch (type) {
                    case 'endFed':
                    case 'randomWire':
                        return '9:1';
                    case 'offCenterDipole':
                    case 'foldedDipole':
                        return '4:1';
                    case 'dipole':
                    case 'quarterVertical':
                    case 'fanDipole':
                    case 'hybrid':
                        return '1:1';
                    default:
                        return null;
                }
            }

            function calculateTrap(freq) {
                const f = freq * 1e6; // Hz
                const L = 10e-6; // 10 µH
                const C = 1 / (4 * Math.PI * Math.PI * f * f * L); // Farads
                return { L: L * 1e6, C: C * 1e12 }; // µH and pF
            }

            function generateTrapFrequencies(operatingFreqs) {
                let traps = [];
                operatingFreqs.sort((a, b) => a - b);
                for (let i = 0; i < operatingFreqs.length - 1; i++) {
                    const trapFreq = (operatingFreqs[i] + operatingFreqs[i + 1]) / 2;
                    traps.push(trapFreq);
                }
                return traps;
            }

            const balunRatio = determineBalunRatio(antennaType);

            calcResults.push(`<b>Fundamental Constants:</b>`);
            calcResults.push(`- Speed of Light (c): ${speedOfLight} m/s`);
            calcResults.push(`- Velocity Factor (VF): ${velocityFactor} (${wireMaterial})`);

            calcResults.push(`<b>Design Parameters:</b>`);
            calcResults.push(`- Antenna Type: ${antennaType}`);
            calcResults.push(`- Wire Material: ${wireMaterial}`);
            calcResults.push(`- Wire Gauge: ${wireGauge} AWG`);
            calcResults.push(`- Target Bands: ${targetBands.map(f => f.toFixed(f < 1 ? 3 : 1)).join(', ')} MHz`);
            if (balunRatio) {
                calcResults.push(`- Balun/UnUn: ${balunRatio}`);
            }

            if (antennaType === 'dipole') {
                const freq = targetBands[0];
                const length = (speedOfLight / (freq * 1000000)) * 0.5 * velocityFactor;
                lengths.push(length);
                frequencies.push(freq);
                types.push('dipole');
                results.push(`Half-Wave Dipole (Designed for ${freq} MHz):`);
                results.push(`- Total Length: ${formatLength(length)}`);
                results.push(`- Each Leg: ${formatLength(length / 2)}`);
                if (useTraps) {
                    trapFrequencies = generateTrapFrequencies(targetBands);
                    trapFrequencies.forEach((freq, index) => {
                        results.push(`- Trap at ${freq.toFixed(1)} MHz: At ~${formatLength(length / 2 / (trapFrequencies.length + 1) * (index + 1))} from feedpoint`);
                    });
                }
                if (balunRatio) results.push(`- Balun (${balunRatio}): At center feedpoint`);
                swrValues = targetBands.map(f => estimateSWR(length, f, 'dipole', balunRatio, trapFrequencies, freq));

                calcResults.push(`<b>Element 1: Half-Wave Dipole at ${freq} MHz</b>`);
                calcResults.push(`- Wavelength (λ) = c / f = ${speedOfLight} / (${freq} × 10⁶) = ${(speedOfLight / (freq * 1000000)).toFixed(2)} m`);
                calcResults.push(`- Total Length = λ × 0.5 × VF = ${(speedOfLight / (freq * 1000000)).toFixed(2)} × 0.5 × ${velocityFactor} = ${length.toFixed(2)} m`);
            } else if (antennaType === 'quarterVertical') {
                const freq = targetBands[0];
                const length = (speedOfLight / (freq * 1000000)) * 0.25 * velocityFactor;
                lengths.push(length);
                frequencies.push(freq);
                types.push('quarterVertical');
                results.push(`Quarter-Wave Vertical (Designed for ${freq} MHz):`);
                results.push(`- Radiator: ${formatLength(length)}`);
                results.push(`- Radial Length: ${formatLength(length)} (suggested)`);
                if (useTraps) {
                    trapFrequencies = generateTrapFrequencies(targetBands);
                    trapFrequencies.forEach((freq, index) => {
                        results.push(`- Trap at ${freq.toFixed(1)} MHz: At ~${formatLength(length / (trapFrequencies.length + 1) * (index + 1))} from base`);
                    });
                }
                if (balunRatio) results.push(`- Balun (${balunRatio}): At base feedpoint`);
                swrValues = targetBands.map(f => estimateSWR(length * 2, f, 'quarterVertical', balunRatio, trapFrequencies, freq));

                calcResults.push(`<b>Element 1: Quarter-Wave Vertical at ${freq} MHz</b>`);
                calcResults.push(`- Wavelength (λ) = c / f = ${speedOfLight} / (${freq} × 10⁶) = ${(speedOfLight / (freq * 1000000)).toFixed(2)} m`);
                calcResults.push(`- Radiator Length = λ × 0.25 × VF = ${(speedOfLight / (freq * 1000000)).toFixed(2)} × 0.25 × ${velocityFactor} = ${length.toFixed(2)} m`);
            } else if (antennaType === 'foldedDipole') {
                const freq = targetBands[0];
                const length = (speedOfLight / (freq * 1000000)) * 0.5 * velocityFactor;
                const spacing = 0.02;
                lengths.push(length);
                frequencies.push(freq);
                types.push('foldedDipole');
                results.push(`Folded Dipole (Designed for ${freq} MHz):`);
                results.push(`- Total Wire Length: ${formatLength(length * 2)}`);
                results.push(`- Each Side: ${formatLength(length)}`);
                results.push(`- Spacing: ${formatLength(spacing)}`);
                if (useTraps) {
                    trapFrequencies = generateTrapFrequencies(targetBands);
                    trapFrequencies.forEach((freq, index) => {
                        results.push(`- Trap at ${freq.toFixed(1)} MHz: At ~${formatLength(length / 2 / (trapFrequencies.length + 1) * (index + 1))} from feedpoint`);
                    });
                }
                if (balunRatio) results.push(`- Balun (${balunRatio}): At top center feedpoint`);
                swrValues = targetBands.map(f => estimateSWR(length, f, 'foldedDipole', balunRatio, trapFrequencies, freq));

                calcResults.push(`<b>Element 1: Folded Dipole at ${freq} MHz</b>`);
                calcResults.push(`- Wavelength (λ) = c / f = ${speedOfLight} / (${freq} × 10⁶) = ${(speedOfLight / (freq * 1000000)).toFixed(2)} m`);
                calcResults.push(`- Side Length = λ × 0.5 × VF = ${(speedOfLight / (freq * 1000000)).toFixed(2)} × 0.5 × ${velocityFactor} = ${length.toFixed(2)} m`);
            } else if (antennaType === 'endFed') {
                const freq = targetBands[0];
                const length = (speedOfLight / (freq * 1000000)) * 0.5 * velocityFactor;
                lengths.push(length);
                frequencies.push(freq);
                types.push('endFed');
                results.push(`End-Fed Wire (Designed for ${freq} MHz):`);
                results.push(`- Total Length: ${formatLength(length)}`);
                if (useTraps) {
                    trapFrequencies = generateTrapFrequencies(targetBands);
                    trapFrequencies.forEach((freq, index) => {
                        results.push(`- Trap at ${freq.toFixed(1)} MHz: At ~${formatLength(length / (trapFrequencies.length + 1) * (index + 1))} from feedpoint`);
                    });
                }
                if (balunRatio) results.push(`- UnUn (${balunRatio}): At end feedpoint`);
                swrValues = targetBands.map(f => estimateSWR(length, f, 'endFed', balunRatio, trapFrequencies, freq));

                calcResults.push(`<b>Element 1: End-Fed Wire at ${freq} MHz</b>`);
                calcResults.push(`- Wavelength (λ) = c / f = ${speedOfLight} / (${freq} × 10⁶) = ${(speedOfLight / (freq * 1000000)).toFixed(2)} m`);
                calcResults.push(`- Total Length = λ × 0.5 × VF = ${(speedOfLight / (freq * 1000000)).toFixed(2)} × 0.5 × ${velocityFactor} = ${length.toFixed(2)} m`);
            } else if (antennaType === 'randomWire') {
                const length = parseFloat(document.getElementById('randomWireLength').value);
                if (isNaN(length) || length <= 0) {
                    alert('Please enter a valid wire length for random wire');
                    return;
                }
                lengths.push(length);
                frequencies.push(targetBands[0]);
                types.push('randomWire');
                results.push(`Random Wire:`);
                results.push(`- Total Length: ${formatLength(length)}`);
                if (useTraps) {
                    trapFrequencies = generateTrapFrequencies(targetBands);
                    trapFrequencies.forEach((freq, index) => {
                        results.push(`- Trap at ${freq.toFixed(1)} MHz: At ~${formatLength(length / (trapFrequencies.length + 1) * (index + 1))} from feedpoint`);
                    });
                }
                if (balunRatio) results.push(`- UnUn (${balunRatio}): At end feedpoint`);
                swrValues = targetBands.map(f => estimateSWR(length, f, 'randomWire', balunRatio, trapFrequencies, targetBands[0]));

                calcResults.push(`<b>Element 1: Random Wire</b>`);
                calcResults.push(`- User-Specified Length: ${length.toFixed(2)} m`);
            } else if (antennaType === 'offCenterDipole') {
                const freq = targetBands[0];
                const length = (speedOfLight / (freq * 1000000)) * 0.5 * velocityFactor;
                lengths.push(length);
                frequencies.push(freq);
                types.push('offCenterDipole');
                results.push(`Off-Center Fed Dipole (Designed for ${freq} MHz):`);
                results.push(`- Total Length: ${formatLength(length)}`);
                results.push(`- Short Leg (1/3): ${formatLength(length / 3)}`);
                results.push(`- Long Leg (2/3): ${formatLength(length * 2 / 3)}`);
                if (useTraps) {
                    trapFrequencies = generateTrapFrequencies(targetBands);
                    trapFrequencies.forEach((freq, index) => {
                        results.push(`- Trap at ${freq.toFixed(1)} MHz: At ~${formatLength((length / 3) / (trapFrequencies.length + 1) * (index + 1))} from feedpoint`);
                    });
                }
                if (balunRatio) results.push(`- Balun (${balunRatio}): At off-center feedpoint`);
                swrValues = targetBands.map(f => estimateSWR(length, f, 'offCenterDipole', balunRatio, trapFrequencies, freq));

                calcResults.push(`<b>Element 1: Off-Center Fed Dipole at ${freq} MHz</b>`);
                calcResults.push(`- Wavelength (λ) = c / f = ${speedOfLight} / (${freq} × 10⁶) = ${(speedOfLight / (freq * 1000000)).toFixed(2)} m`);
                calcResults.push(`- Total Length = λ × 0.5 × VF = ${(speedOfLight / (freq * 1000000)).toFixed(2)} × 0.5 × ${velocityFactor} = ${length.toFixed(2)} m`);
            } else if (antennaType === 'fanDipole') {
                results.push(`Fan Dipole:`);
                calcResults.push(`<b>Fan Dipole Elements:</b>`);
                targetBands.forEach((freq, index) => {
                    const length = (speedOfLight / (freq * 1000000)) * 0.5 * velocityFactor;
                    lengths.push(length);
                    frequencies.push(freq);
                    types.push('dipole');
                    results.push(`- ${freq} MHz: ${formatLength(length)}`);
                    calcResults.push(`Element ${index + 1}: Dipole at ${freq} MHz`);
                    calcResults.push(`- Total Length = λ × 0.5 × VF = ${(speedOfLight / (freq * 1000000)).toFixed(2)} × 0.5 × ${velocityFactor} = ${length.toFixed(2)} m`);
                });
                if (useTraps) {
                    trapFrequencies = generateTrapFrequencies(targetBands);
                    trapFrequencies.forEach((freq, index) => {
                        results.push(`- Trap at ${freq.toFixed(1)} MHz: Between ${targetBands[index].toFixed(1)} and ${targetBands[index + 1].toFixed(1)} MHz elements`);
                    });
                    calcResults.push(`- Traps for multi-band:`);
                    trapFrequencies.forEach(freq => {
                        calcResults.push(`  - ${freq.toFixed(1)} MHz`);
                    });
                }
                if (balunRatio) results.push(`- Balun (${balunRatio}): At common center feedpoint`);
                swrValues = targetBands.map(f => estimateSWR(lengths, f, types, balunRatio, trapFrequencies, frequencies));
            } else if (antennaType === 'hybrid') {
                const hybridTypes = [];
                for (let i = 0; i < hybridElementCount; i++) {
                    hybridTypes.push(document.getElementById(`hybridElement${i}Type`).value);
                }
                if (hybridTypes.length !== targetBands.length) {
                    alert('Number of hybrid elements must match number of target bands');
                    return;
                }

                results.push(`Hybrid Antenna:`);
                calcResults.push(`<b>Hybrid Elements:</b>`);
                targetBands.forEach((freq, index) => {
                    const type = hybridTypes[index];
                    const length = type === 'quarterVertical' ? 
                        (speedOfLight / (freq * 1000000)) * 0.25 * velocityFactor :
                        (speedOfLight / (freq * 1000000)) * 0.5 * velocityFactor;
                    const spacing = type === 'foldedDipole' ? 0.02 : 0;
                    lengths.push(length);
                    frequencies.push(freq);
                    types.push(type);
                    if (type === 'dipole') {
                        results.push(`- Dipole at ${freq} MHz: ${formatLength(length)}`);
                        calcResults.push(`Element ${index + 1}: Dipole at ${freq} MHz`);
                        calcResults.push(`- Total Length = λ × 0.5 × VF = ${(speedOfLight / (freq * 1000000)).toFixed(2)} × 0.5 × ${velocityFactor} = ${length.toFixed(2)} m`);
                    } else if (type === 'quarterVertical') {
                        results.push(`- Vertical at ${freq} MHz: ${formatLength(length)}`);
                        calcResults.push(`Element ${index + 1}: Quarter-Wave Vertical at ${freq} MHz`);
                        calcResults.push(`- Radiator Length = λ × 0.25 × VF = ${(speedOfLight / (freq * 1000000)).toFixed(2)} × 0.25 × ${velocityFactor} = ${length.toFixed(2)} m`);
                    } else if (type === 'foldedDipole') {
                        results.push(`- Folded Dipole at ${freq} MHz: ${formatLength(length * 2)}`);
                        results.push(`  - Spacing: ${formatLength(spacing)}`);
                        calcResults.push(`Element ${index + 1}: Folded Dipole at ${freq} MHz`);
                        calcResults.push(`- Side Length = λ × 0.5 × VF = ${(speedOfLight / (freq * 1000000)).toFixed(2)} × 0.5 × ${velocityFactor} = ${length.toFixed(2)} m`);
                    }
                });
                if (useTraps) {
                    trapFrequencies = generateTrapFrequencies(targetBands);
                    trapFrequencies.forEach((freq, index) => {
                        results.push(`- Trap at ${freq.toFixed(1)} MHz: Between ${targetBands[index].toFixed(1)} and ${targetBands[index + 1].toFixed(1)} MHz elements`);
                    });
                    calcResults.push(`- Traps for multi-band:`);
                    trapFrequencies.forEach(freq => {
                        calcResults.push(`  - ${freq.toFixed(1)} MHz`);
                    });
                }
                if (balunRatio) results.push(`- Balun (${balunRatio}): At common feedpoint`);
                swrValues = targetBands.map(f => estimateSWR(lengths, f, types, balunRatio, trapFrequencies, frequencies));
            }

            if (useTraps && trapFrequencies.length > 0) {
                trapResults.push(`<b>Trap Designs:</b>`);
                trapFrequencies.forEach((freq, index) => {
                    const { L, C } = calculateTrap(freq);
                    trapResults.push(`- Trap ${index + 1} at ${freq.toFixed(1)} MHz:`);
                    trapResults.push(`  - Inductance (L): ${L.toFixed(2)} µH`);
                    trapResults.push(`  - Capacitance (C): ${C.toFixed(2)} pF`);
                    trapResults.push(`  - Note: Adjust L and C for exact resonance.`);
                });
            }

            document.getElementById('resultText').innerHTML = results.join('<br>');
            document.getElementById('calculationText').innerHTML = calcResults.join('<br>');
            document.getElementById('trapDesignText').innerHTML = useTraps && trapFrequencies.length > 0 ? trapResults.join('<br>') : 'No traps used.';
            drawAntenna(antennaType, lengths, frequencies, types, velocityFactor, useBalun, balunRatio, useTraps, trapFrequencies);
            drawSWRPlot(targetBands, swrValues);

            document.getElementById('defaultOpen').click();
        }

        function openTab(evt, tabName) {
            const tabcontent = document.getElementsByClassName('tabcontent');
            for (let i = 0; i < tabcontent.length; i++) {
                tabcontent[i].style.display = 'none';
            }
            const tablinks = document.getElementsByClassName('tablinks');
            for (let i = 0; i < tablinks.length; i++) {
                tablinks[i].className = tablinks[i].className.replace(' active', '');
            }
            document.getElementById(tabName).style.display = 'block';
            evt.currentTarget.className += ' active';
        }

        // Initialize with one band
        addBandFrequency();
    </script>
</body>
</html>
