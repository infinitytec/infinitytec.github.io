<!-- This is an experemental antenna calculation tool written largely by Generative AI. Use at your own risk. As this is written by Generative AI, I am disavowing any copyright on it. -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Wire Antenna Designer</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 900px;
            margin: 20px auto;
            padding: 20px;
        }
        .section {
            margin-bottom: 20px;
        }
        label {
            display: block;
            margin: 5px 0;
        }
        button {
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
        }
        button:hover {
            background-color: #45a049;
        }
        #results {
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #ddd;
        }
        .hidden {
            display: none;
        }
        .remove-btn {
            background-color: #f44336;
            margin-left: 10px;
            padding: 5px 10px;
        }
        .remove-btn:hover {
            background-color: #da190b;
        }
        #antennaCanvas {
            border: 1px solid #000;
            margin-top: 20px;
        }
        .element-container {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        .tab {
            overflow: hidden;
            border: 1px solid #ccc;
            background-color: #f1f1f1;
        }
        .tab button {
            background-color: inherit;
            float: left;
            border: none;
            outline: none;
            cursor: pointer;
            padding: 14px 16px;
            transition: 0.3s;
        }
        .tab button:hover {
            background-color: #ddd;
        }
        .tab button.active {
            background-color: #ccc;
        }
        .tabcontent {
            display: none;
            padding: 6px 12px;
            border: 1px solid #ccc;
            border-top: none;
        }
    </style>
</head>
<body>
    <h1>Advanced Wire Antenna Designer</h1>
    
    <div class="section">
        <h2>Input Parameters</h2>
        <label>
            Primary Frequency (MHz):
            <input type="number" id="frequency" step="0.1" min="0.1" value="14.2">
        </label>
        <label>
            Antenna Type:
            <select id="antennaType" onchange="toggleAdvancedOptions()">
                <option value="dipole">Half-Wave Dipole</option>
                <option value="quarterVertical">Quarter-Wave Vertical</option>
                <option value="foldedDipole">Folded Dipole</option>
                <option value="fanDipole">Fan Dipole</option>
                <option value="hybrid">Hybrid (Custom Elements)</option>
                <option value="endFed">End-Fed Wire</option>
            </select>
        </label>
        <label>
            Velocity Factor (0-1, default 0.95 for bare wire):
            <input type="number" id="velocityFactor" step="0.01" min="0" max="1" value="0.95">
        </label>
        <label>
            Wire Material:
            <select id="wireMaterial">
                <option value="copper">Copper (VF: 0.95)</option>
                <option value="aluminum">Aluminum (VF: 0.93)</option>
                <option value="insulated">Insulated Copper (VF: 0.90)</option>
            </select>
        </label>
        <label>
            Wire Gauge (AWG):
            <input type="number" id="wireGauge" min="6" max="30" value="14">
        </label>
        <label>
            Use Balun:
            <input type="checkbox" id="useBalun" onchange="toggleBalunOptions()">
        </label>
        <div id="balunOptions" class="hidden">
            <label>
                Balun Ratio:
                <select id="balunRatio">
                    <option value="1:1">1:1</option>
                    <option value="4:1">4:1</option>
                    <option value="9:1">9:1</option>
                </select>
            </label>
        </div>
        <label>
            Use Traps (for multi-band):
            <input type="checkbox" id="useTraps" onchange="toggleTrapOptions()">
        </label>
        <div id="trapOptions" class="hidden">
            <h3>Trap Frequencies</h3>
            <div id="trapFrequencies"></div>
            <button onclick="addTrapFrequency()">Add Trap Frequency</button>
        </div>

        <!-- Advanced Options for Fan Dipole -->
        <div id="fanDipoleOptions" class="hidden">
            <h3>Fan Dipole Elements</h3>
            <div id="fanFrequencies"></div>
            <button onclick="addFanFrequency()">Add Frequency</button>
        </div>

        <!-- Advanced Options for Hybrid -->
        <div id="hybridOptions" class="hidden">
            <h3>Hybrid Elements</h3>
            <div id="hybridElements"></div>
            <button onclick="addHybridElement()">Add Element</button>
        </div>

        <button onclick="calculateAntenna()">Calculate</button>
    </div>

    <div id="results">
        <h2>Results</h2>
        <div class="tab">
            <button class="tablinks" onclick="openTab(event, 'Design')" id="defaultOpen">Design</button>
            <button class="tablinks" onclick="openTab(event, 'Calculations')">Calculations</button>
        </div>

        <div id="Design" class="tabcontent">
            <p id="resultText">Enter parameters and click Calculate to see results.</p>
            <canvas id="antennaCanvas" width="600" height="400"></canvas>
        </div>

        <div id="Calculations" class="tabcontent">
            <p id="calculationText">Calculations will appear here after clicking Calculate.</p>
        </div>
    </div>

    <script>
        let fanFreqCount = 0;
        let hybridElementCount = 0;
        let trapFreqCount = 0;

        function toggleAdvancedOptions() {
            const antennaType = document.getElementById('antennaType').value;
            document.getElementById('fanDipoleOptions').classList.toggle('hidden', antennaType !== 'fanDipole');
            document.getElementById('hybridOptions').classList.toggle('hidden', antennaType !== 'hybrid');
            if (antennaType === 'fanDipole' && fanFreqCount === 0) {
                addFanFrequency();
            }
            if (antennaType === 'hybrid' && hybridElementCount === 0) {
                addHybridElement();
            }
        }

        function toggleBalunOptions() {
            const useBalun = document.getElementById('useBalun').checked;
            document.getElementById('balunOptions').classList.toggle('hidden', !useBalun);
        }

        function toggleTrapOptions() {
            const useTraps = document.getElementById('useTraps').checked;
            const antennaType = document.getElementById('antennaType').value;
            document.getElementById('trapOptions').classList.toggle('hidden', !useTraps || !['fanDipole', 'hybrid'].includes(antennaType));
            if (useTraps && ['fanDipole', 'hybrid'].includes(antennaType) && trapFreqCount === 0) {
                addTrapFrequency();
            }
        }

        function addFanFrequency() {
            const fanFrequencies = document.getElementById('fanFrequencies');
            const freqId = `fanFreq${fanFreqCount}`;
            const div = document.createElement('div');
            div.innerHTML = `
                <label>
                    Additional Frequency ${fanFreqCount + 1} (MHz):
                    <input type="number" id="${freqId}" step="0.1" min="0.1" value="${7.1 + fanFreqCount * 7}">
                    <button class="remove-btn" onclick="removeFanFrequency(this)">Remove</button>
                </label>
            `;
            fanFrequencies.appendChild(div);
            fanFreqCount++;
        }

        function removeFanFrequency(button) {
            if (fanFreqCount > 1) {
                button.parentElement.parentElement.remove();
                fanFreqCount--;
            }
        }

        function addHybridElement() {
            const hybridElements = document.getElementById('hybridElements');
            const elementId = `hybridElement${hybridElementCount}`;
            const div = document.createElement('div');
            div.className = 'element-container';
            div.innerHTML = `
                <label>
                    Frequency ${hybridElementCount + 1} (MHz):
                    <input type="number" id="${elementId}Freq" step="0.1" min="0.1" value="${14.2 - hybridElementCount * 7}">
                </label>
                <label>
                    Type:
                    <select id="${elementId}Type">
                        <option value="dipole">Half-Wave Dipole</option>
                        <option value="quarterVertical">Quarter-Wave Vertical</option>
                        <option value="foldedDipole">Folded Dipole</option>
                    </select>
                </label>
                <button class="remove-btn" onclick="removeHybridElement(this)">Remove</button>
            `;
            hybridElements.appendChild(div);
            hybridElementCount++;
        }

        function removeHybridElement(button) {
            if (hybridElementCount > 1) {
                button.parentElement.remove();
                hybridElementCount--;
            }
        }

        function addTrapFrequency() {
            const trapFrequencies = document.getElementById('trapFrequencies');
            const freqId = `trapFreq${trapFreqCount}`;
            const div = document.createElement('div');
            div.innerHTML = `
                <label>
                    Trap Frequency ${trapFreqCount + 1} (MHz):
                    <input type="number" id="${freqId}" step="0.1" min="0.1" value="${14.2 - trapFreqCount * 7}">
                    <button class="remove-btn" onclick="removeTrapFrequency(this)">Remove</button>
                </label>
            `;
            trapFrequencies.appendChild(div);
            trapFreqCount++;
        }

        function removeTrapFrequency(button) {
            if (trapFreqCount > 1) {
                button.parentElement.remove();
                trapFreqCount--;
            }
        }

        function drawAntenna(antennaType, lengths, frequencies, types, velocityFactor, useBalun, balunRatio, useTraps, trapFrequencies) {
            const canvas = document.getElementById('antennaCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const maxLength = Math.max(...lengths);
            const scale = Math.min(20, (canvas.width - 150) / (maxLength * 2));
            const cutGap = 10;

            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2;
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';

            function drawFeedPoint(x, y, label = false) {
                ctx.beginPath();
                ctx.arc(x, y, 5, 0, 2 * Math.PI);
                ctx.fillStyle = '#FF0000';
                ctx.fill();
                if (label) {
                    ctx.fillStyle = '#000';
                    ctx.fillText('Feed Point', x, y - 25);
                }
            }

            function drawGroundPlane(x, y, length) {
                ctx.strokeStyle = '#666';
                ctx.beginPath();
                ctx.moveTo(x - length * scale, y);
                ctx.lineTo(x + length * scale, y);
                ctx.stroke();
                ctx.strokeStyle = '#000';
                ctx.fillText(`Ground Plane: ${length.toFixed(2)} m`, x, y + 30);
            }

            function drawBalun(x, y, ratio) {
                ctx.fillStyle = '#00F';
                ctx.fillRect(x - 10, y - 5, 20, 10);
                ctx.fillStyle = '#000';
                ctx.fillText(`Balun (${ratio})`, x, y - 35);
            }

            function drawTrap(x, y, freq) {
                ctx.fillStyle = '#0F0';
                ctx.fillRect(x - 5, y - 5, 10, 10);
                ctx.fillStyle = '#000';
                ctx.fillText(`${freq.toFixed(1)}`, x, y + 20); // Cleaner label
            }

            if (antennaType === 'dipole') {
                const length = lengths[0] / 2;
                ctx.beginPath();
                ctx.moveTo(centerX - length * scale, centerY);
                ctx.lineTo(centerX - cutGap / 2, centerY);
                ctx.moveTo(centerX + cutGap / 2, centerY);
                ctx.lineTo(centerX + length * scale, centerY);
                ctx.stroke();
                drawFeedPoint(centerX, centerY, true);
                if (useBalun) drawBalun(centerX, centerY, balunRatio);
                ctx.fillText(`${length.toFixed(2)} m`, centerX - length * scale / 2, centerY + 20);
                ctx.fillText(`${length.toFixed(2)} m`, centerX + length * scale / 2, centerY + 20);
            } else if (antennaType === 'quarterVertical') {
                const length = lengths[0];
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(centerX, centerY - length * scale);
                ctx.stroke();
                drawFeedPoint(centerX, centerY, true);
                if (useBalun) drawBalun(centerX, centerY, balunRatio);
                drawGroundPlane(centerX, centerY, length);
                ctx.textAlign = 'left';
                ctx.fillText(`${length.toFixed(2)} m`, centerX + 60, centerY - length * scale / 2);
                ctx.textAlign = 'center';
            } else if (antennaType === 'foldedDipole') {
                const length = lengths[0] / 2;
                const height = 20;
                const spacing = 0.02;
                const totalWireLength = lengths[0] * 2;
                ctx.beginPath();
                ctx.moveTo(centerX - length * scale, centerY - height);
                ctx.lineTo(centerX - cutGap / 2, centerY - height);
                ctx.moveTo(centerX + cutGap / 2, centerY - height);
                ctx.lineTo(centerX + length * scale, centerY - height);
                ctx.lineTo(centerX + length * scale, centerY + height);
                ctx.lineTo(centerX - length * scale, centerY + height);
                ctx.lineTo(centerX - length * scale, centerY - height);
                ctx.stroke();
                drawFeedPoint(centerX, centerY - height, true);
                if (useBalun) drawBalun(centerX, centerY - height, balunRatio);
                CTX.fillText(`${length.toFixed(2)} m`, centerX - length * scale / 2, centerY - height - 30);
                ctx.fillText(`${length.toFixed(2)} m`, centerX + length * scale / 2, centerY - height - 30);
                ctx.fillText(`Spacing: ${spacing.toFixed(2)} m`, centerX, centerY + height + 20);
                ctx.fillText(`Total Wire: ${totalWireLength.toFixed(2)} m`, centerX, centerY + height + 35);
            } else if (antennaType === 'endFed') {
                const length = lengths[0];
                ctx.beginPath();
                ctx.moveTo(centerX - length * scale, centerY);
                ctx.lineTo(centerX, centerY);
                ctx.stroke();
                drawFeedPoint(centerX - length * scale, centerY, true);
                if (useBalun) drawBalun(centerX - length * scale, centerY, balunRatio);
                ctx.textAlign = 'left';
                ctx.fillText(`${length.toFixed(2)} m`, centerX - length * scale / 2, centerY + 20);
                ctx.textAlign = 'center';
            } else if (antennaType === 'fanDipole' || antennaType === 'hybrid') {
                const totalHeight = (lengths.length - 1) * 60;
                let trapIndex = 0;
                lengths.forEach((length, index) => {
                    const yOffset = centerY - totalHeight / 2 + index * 60;
                    const elementType = types[index];
                    if (elementType === 'dipole') {
                        const halfLength = length / 2;
                        ctx.beginPath();
                        ctx.moveTo(centerX - halfLength * scale, yOffset);
                        ctx.lineTo(centerX - cutGap / 2, yOffset);
                        ctx.moveTo(centerX + cutGap / 2, yOffset);
                        ctx.lineTo(centerX + halfLength * scale, yOffset);
                        ctx.stroke();
                        drawFeedPoint(centerX, yOffset, index === 0);
                        if (useBalun && index === 0) drawBalun(centerX, yOffset, balunRatio);
                        if (useTraps && trapIndex < trapFrequencies.length && index > 0) {
                            const trapSpacing = halfLength / 2;
                            drawTrap(centerX - trapSpacing * scale, yOffset, trapFrequencies[trapIndex]);
                            drawTrap(centerX + trapSpacing * scale, yOffset, trapFrequencies[trapIndex]);
                            trapIndex++;
                        }
                        ctx.fillText(`${halfLength.toFixed(2)} m`, centerX - halfLength * scale / 2, yOffset + 20);
                        ctx.fillText(`${halfLength.toFixed(2)} m`, centerX + halfLength * scale / 2, yOffset + 20);
                        ctx.textAlign = 'left';
                        ctx.fillText(`${length.toFixed(2)} m (${frequencies[index].toFixed(1)} MHz)`, 
                            centerX + halfLength * scale + 10, yOffset - 10);
                        ctx.textAlign = 'center';
                    } else if (elementType === 'quarterVertical') {
                        ctx.beginPath();
                        ctx.moveTo(centerX, yOffset);
                        ctx.lineTo(centerX, yOffset - length * scale);
                        ctx.stroke();
                        drawFeedPoint(centerX, yOffset, index === 0);
                        if (useBalun && index === 0) drawBalun(centerX, yOffset, balunRatio);
                        drawGroundPlane(centerX, yOffset, length);
                        ctx.textAlign = 'left';
                        ctx.fillText(`${length.toFixed(2)} m (${frequencies[index].toFixed(1)} MHz)`, 
                            centerX + 60, yOffset - length * scale / 2);
                        ctx.textAlign = 'center';
                    } else if (elementType === 'foldedDipole') {
                        const halfLength = length / 2;
                        const height = 20;
                        const spacing = 0.02;
                        const totalWireLength = length * 2;
                        ctx.beginPath();
                        ctx.moveTo(centerX - halfLength * scale, yOffset - height);
                        ctx.lineTo(centerX - cutGap / 2, yOffset - height);
                        ctx.moveTo(centerX + cutGap / 2, yOffset - height);
                        ctx.lineTo(centerX + halfLength * scale, yOffset - height);
                        ctx.lineTo(centerX + halfLength * scale, yOffset + height);
                        ctx.lineTo(centerX - halfLength * scale, yOffset + height);
                        ctx.lineTo(centerX - halfLength * scale, yOffset - height);
                        ctx.stroke();
                        drawFeedPoint(centerX, yOffset - height, index === 0);
                        if (useBalun && index === 0) drawBalun(centerX, yOffset - height, balunRatio);
                        if (useTraps && trapIndex < trapFrequencies.length && index > 0) {
                            const trapSpacing = halfLength / 2;
                            drawTrap(centerX - trapSpacing * scale, yOffset, trapFrequencies[trapIndex]);
                            drawTrap(centerX + trapSpacing * scale, yOffset, trapFrequencies[trapIndex]);
                            trapIndex++;
                        }
                        ctx.fillText(`${halfLength.toFixed(2)} m`, centerX - halfLength * scale / 2, yOffset - height - 30);
                        ctx.fillText(`${halfLength.toFixed(2)} m`, centerX + halfLength * scale / 2, yOffset - height - 30);
                        ctx.textAlign = 'left';
                        ctx.fillText(`${totalWireLength.toFixed(2)} m (${frequencies[index].toFixed(1)} MHz)`, 
                            centerX + halfLength * scale + 10, yOffset - 10);
                        ctx.fillText(`Spacing: ${spacing.toFixed(2)} m`, centerX + halfLength * scale + 10, yOffset + 5);
                        ctx.textAlign = 'center';
                    }
                });
            }
        }

        function calculateAntenna() {
            const frequency = parseFloat(document.getElementById('frequency').value);
            const antennaType = document.getElementById('antennaType').value;
            let velocityFactor = parseFloat(document.getElementById('velocityFactor').value);
            const wireMaterial = document.getElementById('wireMaterial').value;
            const wireGauge = parseInt(document.getElementById('wireGauge').value);
            const useBalun = document.getElementById('useBalun').checked;
            const balunRatio = useBalun ? document.getElementById('balunRatio').value : null;
            const useTraps = document.getElementById('useTraps').checked && ['fanDipole', 'hybrid'].includes(antennaType);

            const materialVF = {
                'copper': 0.95,
                'aluminum': 0.93,
                'insulated': 0.90
            };
            if (velocityFactor === 0.95 && wireMaterial !== 'copper') {
                velocityFactor = materialVF[wireMaterial];
            }

            if (isNaN(frequency) || frequency <= 0) {
                alert('Please enter a valid primary frequency');
                return;
            }
            if (isNaN(velocityFactor) || velocityFactor <= 0 || velocityFactor > 1) {
                alert('Please enter a valid velocity factor between 0 and 1');
                return;
            }
            if (wireGauge < 6 || wireGauge > 30) {
                alert('Wire gauge should be between 6 and 30 AWG');
                return;
            }

            let trapFrequencies = [];
            if (useTraps) {
                for (let i = 0; i < trapFreqCount; i++) {
                    const freq = parseFloat(document.getElementById(`trapFreq${i}`).value);
                    if (isNaN(freq) || freq <= 0) {
                        alert(`Please enter a valid trap frequency for trap ${i + 1}`);
                        return;
                    }
                    trapFrequencies.push(freq);
                }
            }

            const speedOfLight = 299792458; // meters per second
            const wavelength = speedOfLight / (frequency * 1000000);
            let results = [];
            let calcResults = [];
            let lengths = [];
            let frequencies = [];
            let types = [];

            function formatLength(length) {
                const feet = length * 3.28084;
                const inches = feet * 12;
                return `${length.toFixed(2)} m (${feet.toFixed(2)} ft, ${inches.toFixed(2)} in)`;
            }

            function estimateSWR(length, freq, type) {
                const idealLength = type === 'quarterVertical' ? 
                    (speedOfLight / (freq * 1000000)) * 0.25 * velocityFactor :
                    (speedOfLight / (freq * 1000000)) * 0.5 * velocityFactor;
                const deviation = Math.abs(length - idealLength) / idealLength;
                return Math.max(1, 1 + deviation * 10).toFixed(1);
            }

            function needsBalun(type, balunRatio) {
                if (!useBalun) return false;
                if (type === 'endFed' && balunRatio !== '9:1') return true; // End-fed typically needs 9:1
                if (type === 'foldedDipole' && balunRatio === '4:1') return true; // Folded dipole often needs 4:1 for 300Ω to 75Ω
                if (['dipole', 'quarterVertical', 'fanDipole', 'hybrid'].includes(type) && balunRatio === '1:1') return true; // 1:1 common for balanced feed
                return false;
            }

            calcResults.push(`Constants:`);
            calcResults.push(`- Speed of Light (c): ${speedOfLight} m/s`);
            calcResults.push(`- Velocity Factor (VF): ${velocityFactor}`);

            if (antennaType === 'dipole') {
                const length = wavelength * 0.5 * velocityFactor;
                lengths.push(length);
                frequencies.push(frequency);
                types.push('dipole');
                results.push(`Half-Wave Dipole: Total length = ${formatLength(length)}`);
                results.push(`Each leg: ${formatLength(length / 2)}`);
                if (needsBalun('dipole', balunRatio)) results.push(`Balun (${balunRatio}): Place at the feedpoint (center of dipole)`);
                results.push(`Estimated SWR at ${frequency} MHz: ${estimateSWR(length, frequency, 'dipole')}`);
                calcResults.push(`Element 1 (${frequency} MHz, Dipole):`);
                calcResults.push(`- Wavelength (λ) = c / f = ${speedOfLight} / (${frequency} × 10⁶) = ${(speedOfLight / (frequency * 1000000)).toFixed(2)} m`);
                calcResults.push(`- Total Length = λ × 0.5 × VF = ${(speedOfLight / (frequency * 1000000)).toFixed(2)} × 0.5 × ${velocityFactor} = ${length.toFixed(2)} m`);
                calcResults.push(`- Primary SWR = max(1, 1 + |${length.toFixed(2)} - ${length.toFixed(2)}| / ${length.toFixed(2)} × 10) = ${estimateSWR(length, frequency, 'dipole')}`);
            } else if (antennaType === 'quarterVertical') {
                const length = wavelength * 0.25 * velocityFactor;
                lengths.push(length);
                frequencies.push(frequency);
                types.push('quarterVertical');
                results.push(`Quarter-Wave Vertical: Radiator = ${formatLength(length)}`);
                results.push(`Radial length (suggested): ${formatLength(length)}`);
                if (needsBalun('quarterVertical', balunRatio)) results.push(`Balun (${balunRatio}): Place at the feedpoint (base of vertical)`);
                results.push(`Estimated SWR at ${frequency} MHz: ${estimateSWR(length * 2, frequency, 'quarterVertical')}`);
                calcResults.push(`Element 1 (${frequency} MHz, Quarter-Wave Vertical):`);
                calcResults.push(`- Wavelength (λ) = c / f = ${speedOfLight} / (${frequency} × 10⁶) = ${(speedOfLight / (frequency * 1000000)).toFixed(2)} m`);
                calcResults.push(`- Radiator Length = λ × 0.25 × VF = ${(speedOfLight / (frequency * 1000000)).toFixed(2)} × 0.25 × ${velocityFactor} = ${length.toFixed(2)} m`);
                calcResults.push(`- Primary SWR = max(1, 1 + |${(length * 2).toFixed(2)} - ${(speedOfLight / (frequency * 1000000) * 0.5 * velocityFactor).toFixed(2)}| / ${(speedOfLight / (frequency * 1000000) * 0.5 * velocityFactor).toFixed(2)} × 10) = ${estimateSWR(length * 2, frequency, 'quarterVertical')}`);
            } else if (antennaType === 'foldedDipole') {
                const length = wavelength * 0.5 * velocityFactor;
                const spacing = 0.02;
                lengths.push(length);
                frequencies.push(frequency);
                types.push('foldedDipole');
                results.push(`Folded Dipole: Total wire length = ${formatLength(length * 2)}`);
                results.push(`Each side length: ${formatLength(length)}`);
                results.push(`Spacing between parallel wires: ${formatLength(spacing)}`);
                if (needsBalun('foldedDipole', balunRatio)) results.push(`Balun (${balunRatio}): Place at the feedpoint (center of top wire)`);
                results.push(`Estimated SWR at ${frequency} MHz: ${estimateSWR(length, frequency, 'foldedDipole')} (typically 300Ω impedance)`);
                calcResults.push(`Element 1 (${frequency} MHz, Folded Dipole):`);
                calcResults.push(`- Wavelength (λ) = c / f = ${speedOfLight} / (${frequency} × 10⁶) = ${(speedOfLight / (frequency * 1000000)).toFixed(2)} m`);
                calcResults.push(`- Side Length = λ × 0.5 × VF = ${(speedOfLight / (frequency * 1000000)).toFixed(2)} × 0.5 × ${velocityFactor} = ${length.toFixed(2)} m`);
                calcResults.push(`- Total Wire Length = 2 × ${length.toFixed(2)} = ${(length * 2).toFixed(2)} m`);
                calcResults.push(`- Primary SWR = max(1, 1 + |${length.toFixed(2)} - ${length.toFixed(2)}| / ${length.toFixed(2)} × 10) = ${estimateSWR(length, frequency, 'foldedDipole')}`);
            } else if (antennaType === 'endFed') {
                const length = wavelength * 0.5 * velocityFactor; // Half-wave end-fed
                lengths.push(length);
                frequencies.push(frequency);
                types.push('endFed');
                results.push(`End-Fed Wire: Total length = ${formatLength(length)}`);
                if (needsBalun('endFed', balunRatio)) results.push(`Balun (${balunRatio}): Place at the feedpoint (end of wire)`);
                results.push(`Estimated SWR at ${frequency} MHz: ${estimateSWR(length, frequency, 'endFed')} (high impedance, typically requires 9:1 balun)`);
                calcResults.push(`Element 1 (${frequency} MHz, End-Fed Wire):`);
                calcResults.push(`- Wavelength (λ) = c / f = ${speedOfLight} / (${frequency} × 10⁶) = ${(speedOfLight / (frequency * 1000000)).toFixed(2)} m`);
                calcResults.push(`- Total Length = λ × 0.5 × VF = ${(speedOfLight / (frequency * 1000000)).toFixed(2)} × 0.5 × ${velocityFactor} = ${length.toFixed(2)} m`);
                calcResults.push(`- Primary SWR = max(1, 1 + |${length.toFixed(2)} - ${length.toFixed(2)}| / ${length.toFixed(2)} × 10) = ${estimateSWR(length, frequency, 'endFed')}`);
            } else if (antennaType === 'fanDipole') {
                const fanFrequencies = [];
                fanFrequencies.push(frequency);
                for (let i = 0; i < fanFreqCount; i++) {
                    const freq = parseFloat(document.getElementById(`fanFreq${i}`).value);
                    if (isNaN(freq) || freq <= 0) {
                        alert(`Please enter a valid frequency for element ${i + 1}`);
                        return;
                    }
                    fanFrequencies.push(freq);
                }

                results.push(`Fan Dipole:`);
                fanFrequencies.forEach((freq, index) => {
                    const length = (speedOfLight / (freq * 1000000)) * 0.5 * velocityFactor;
                    lengths.push(length);
                    frequencies.push(freq);
                    types.push('dipole');
                    results.push(`- ${freq} MHz: ${formatLength(length)}`);
                    if (useTraps && trapFrequencies.length > 0 && index > 0 && index <= trapFrequencies.length) {
                        results.push(`  Traps (${trapFrequencies[index - 1]} MHz): Place at approximately 1/4 of the total length from the feedpoint on each side`);
                    }
                    fanFrequencies.forEach(testFreq => {
                        results.push(`  SWR at ${testFreq} MHz: ${estimateSWR(length, testFreq, 'dipole')}`);
                    });
                    calcResults.push(`Element ${index + 1} (${freq} MHz, Dipole):`);
                    calcResults.push(`- Wavelength (λ) = c / f = ${speedOfLight} / (${freq} × 10⁶) = ${(speedOfLight / (freq * 1000000)).toFixed(2)} m`);
                    calcResults.push(`- Total Length = λ × 0.5 × VF = ${(speedOfLight / (freq * 1000000)).toFixed(2)} × 0.5 × ${velocityFactor} = ${length.toFixed(2)} m`);
                    calcResults.push(`- Primary SWR = max(1, 1 + |${length.toFixed(2)} - ${(speedOfLight / (freq * 1000000) * 0.5 * velocityFactor).toFixed(2)}| / ${(speedOfLight / (freq * 1000000) * 0.5 * velocityFactor).toFixed(2)} × 10) = ${estimateSWR(length, freq, 'dipole')}`);
                });
                if (needsBalun('fanDipole', balunRatio)) results.push(`Balun (${balunRatio}): Place at the common feedpoint (center of all elements)`);
            } else if (antennaType === 'hybrid') {
                const hybridFrequencies = [];
                const hybridTypes = [];
                hybridFrequencies.push(frequency);
                hybridTypes.push(document.getElementById(`hybridElement0Type`).value);
                for (let i = 1; i < hybridElementCount; i++) {
                    const freq = parseFloat(document.getElementById(`hybridElement${i}Freq`).value);
                    const type = document.getElementById(`hybridElement${i}Type`).value;
                    if (isNaN(freq) || freq <= 0) {
                        alert(`Please enter a valid frequency for element ${i + 1}`);
                        return;
                    }
                    hybridFrequencies.push(freq);
                    hybridTypes.push(type);
                }

                results.push(`Hybrid Antenna:`);
                hybridFrequencies.forEach((freq, index) => {
                    const type = hybridTypes[index];
                    const length = type === 'quarterVertical' ? 
                        (speedOfLight / (freq * 1000000)) * 0.25 * velocityFactor :
                        (speedOfLight / (freq * 1000000)) * 0.5 * velocityFactor;
                    const spacing = type === 'foldedDipole' ? 0.02 : 0;
                    lengths.push(length);
                    frequencies.push(freq);
                    types.push(type);
                    if (type === 'dipole') {
                        results.push(`- Dipole at ${freq} MHz: Total length = ${formatLength(length)}`);
                        results.push(`  Each leg: ${formatLength(length / 2)}`);
                        if (useTraps && trapFrequencies.length > 0 && index > 0 && index <= trapFrequencies.length) {
                            results.push(`  Traps (${trapFrequencies[index - 1]} MHz): Place at approximately 1/4 of the total length from the feedpoint on each side`);
                        }
                        calcResults.push(`Element ${index + 1} (${freq} MHz, Dipole):`);
                        calcResults.push(`- Wavelength (λ) = c / f = ${speedOfLight} / (${freq} × 10⁶) = ${(speedOfLight / (freq * 1000000)).toFixed(2)} m`);
                        calcResults.push(`- Total Length = λ × 0.5 × VF = ${(speedOfLight / (freq * 1000000)).toFixed(2)} × 0.5 × ${velocityFactor} = ${length.toFixed(2)} m`);
                        calcResults.push(`- Primary SWR = max(1, 1 + |${length.toFixed(2)} - ${(speedOfLight / (freq * 1000000) * 0.5 * velocityFactor).toFixed(2)}| / ${(speedOfLight / (freq * 1000000) * 0.5 * velocityFactor).toFixed(2)} × 10) = ${estimateSWR(length, freq, 'dipole')}`);
                    } else if (type === 'quarterVertical') {
                        results.push(`- Vertical at ${freq} MHz: Radiator = ${formatLength(length)}`);
                        results.push(`  Ground Plane Length: ${formatLength(length)}`);
                        calcResults.push(`Element ${index + 1} (${freq} MHz, Quarter-Wave Vertical):`);
                        calcResults.push(`- Wavelength (λ) = c / f = ${speedOfLight} / (${freq} × 10⁶) = ${(speedOfLight / (freq * 1000000)).toFixed(2)} m`);
                        calcResults.push(`- Radiator Length = λ × 0.25 × VF = ${(speedOfLight / (freq * 1000000)).toFixed(2)} × 0.25 × ${velocityFactor} = ${length.toFixed(2)} m`);
                        calcResults.push(`- Primary SWR = max(1, 1 + |${(length * 2).toFixed(2)} - ${(speedOfLight / (freq * 1000000) * 0.5 * velocityFactor).toFixed(2)}| / ${(speedOfLight / (freq * 1000000) * 0.5 * velocityFactor).toFixed(2)} × 10) = ${estimateSWR(length * 2, freq, 'quarterVertical')}`);
                    } else if (type === 'foldedDipole') {
                        results.push(`- Folded Dipole at ${freq} MHz: Total wire length = ${formatLength(length * 2)}`);
                        results.push(`  Each side length: ${formatLength(length)}`);
                        results.push(`  Spacing between parallel wires: ${formatLength(spacing)}`);
                        if (useTraps && trapFrequencies.length > 0 && index > 0 && index <= trapFrequencies.length) {
                            results.push(`  Traps (${trapFrequencies[index - 1]} MHz): Place at approximately 1/4 of the total length from the feedpoint on each side`);
                        }
                        calcResults.push(`Element ${index + 1} (${freq} MHz, Folded Dipole):`);
                        calcResults.push(`- Wavelength (λ) = c / f = ${speedOfLight} / (${freq} × 10⁶) = ${(speedOfLight / (freq * 1000000)).toFixed(2)} m`);
                        calcResults.push(`- Side Length = λ × 0.5 × VF = ${(speedOfLight / (freq * 1000000)).toFixed(2)} × 0.5 × ${velocityFactor} = ${length.toFixed(2)} m`);
                        calcResults.push(`- Total Wire Length = 2 × ${length.toFixed(2)} = ${(length * 2).toFixed(2)} m`);
                        calcResults.push(`- Primary SWR = max(1, 1 + |${length.toFixed(2)} - ${(speedOfLight / (freq * 1000000) * 0.5 * velocityFactor).toFixed(2)}| / ${(speedOfLight / (freq * 1000000) * 0.5 * velocityFactor).toFixed(2)} × 10) = ${estimateSWR(length, freq, 'foldedDipole')}`);
                    }
                    hybridFrequencies.forEach(testFreq => {
                        results.push(`  SWR at ${testFreq} MHz: ${estimateSWR(length, testFreq, type)}`);
                    });
                });
                if (needsBalun('hybrid', balunRatio)) results.push(`Balun (${balunRatio}): Place at the common feedpoint (center/base of all elements)`);
            }

            results.push(`Wire Material: ${wireMaterial}`);
            results.push(`Wire Gauge: ${wireGauge} AWG`);
            results.push(`Velocity Factor Used: ${velocityFactor}`);

            document.getElementById('resultText').innerHTML = results.join('<br>');
            document.getElementById('calculationText').innerHTML = calcResults.join('<br>');
            drawAntenna(antennaType, lengths, frequencies, types, velocityFactor, needsBalun(antennaType, balunRatio), balunRatio, useTraps, trapFrequencies);

            document.getElementById('defaultOpen').click();
        }

        function openTab(evt, tabName) {
            const tabcontent = document.getElementsByClassName('tabcontent');
            for (let i = 0; i < tabcontent.length; i++) {
                tabcontent[i].style.display = 'none';
            }
            const tablinks = document.getElementsByClassName('tablinks');
            for (let i = 0; i < tablinks.length; i++) {
                tablinks[i].className = tablinks[i].className.replace(' active', '');
            }
            document.getElementById(tabName).style.display = 'block';
            evt.currentTarget.className += ' active';
        }
    </script>
</body>
</html>
