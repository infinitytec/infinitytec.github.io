<!-- This is an experemental antenna calculation tool written largely by Generative AI. Use at your own risk. As this is written by Generative AI, I am disavowing any copyright on it. -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Wire Antenna Designer</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 900px;
            margin: 20px auto;
            padding: 20px;
        }
        .section {
            margin-bottom: 20px;
        }
        label {
            display: block;
            margin: 5px 0;
        }
        button {
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            cursor: pointer;
        }
        button:hover {
            background-color: #45a049;
        }
        #results {
            margin-top: 20px;
            padding: 10px;
            border: 1px solid #ddd;
        }
        .hidden {
            display: none;
        }
        .remove-btn {
            background-color: #f44336;
            margin-left: 10px;
            padding: 5px 10px;
        }
        .remove-btn:hover {
            background-color: #da190b;
        }
        #antennaCanvas {
            border: 1px solid #000;
            margin-top: 20px;
        }
        .element-container {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        .tab {
            overflow: hidden;
            border: 1px solid #ccc;
            background-color: #f1f1f1;
        }
        .tab button {
            background-color: inherit;
            float: left;
            border: none;
            outline: none;
            cursor: pointer;
            padding: 14px 16px;
            transition: 0.3s;
        }
        .tab button:hover {
            background-color: #ddd;
        }
        .tab button.active {
            background-color: #ccc;
        }
        .tabcontent {
            display: none;
            padding: 6px 12px;
            border: 1px solid #ccc;
            border-top: none;
        }
    </style>
</head>
<body>
    <h1>Advanced Wire Antenna Designer</h1>
    
    <div class="section">
        <h2>Input Parameters</h2>
        <label>
            Primary Frequency (MHz):
            <input type="number" id="frequency" step="0.1" min="0.1" value="14.2">
        </label>
        <label>
            Antenna Type:
            <select id="antennaType" onchange="toggleAdvancedOptions()">
                <option value="dipole">Half-Wave Dipole</option>
                <option value="quarterVertical">Quarter-Wave Vertical</option>
                <option value="foldedDipole">Folded Dipole</option>
                <option value="fanDipole">Fan Dipole</option>
                <option value="hybrid">Hybrid (Custom Elements)</option>
                <option value="endFed">End-Fed Wire</option>
            </select>
        </label>
        <label>
            Velocity Factor (0-1, default 0.95 for bare wire):
            <input type="number" id="velocityFactor" step="0.01" min="0" max="1" value="0.95">
        </label>
        <label>
            Wire Material:
            <select id="wireMaterial">
                <option value="copper">Copper (VF: 0.95)</option>
                <option value="aluminum">Aluminum (VF: 0.93)</option>
                <option value="insulated">Insulated Copper (VF: 0.90)</option>
            </select>
        </label>
        <label>
            Wire Gauge (AWG):
            <input type="number" id="wireGauge" min="6" max="30" value="14">
        </label>
        <label>
            Use Balun/UnUn:
            <input type="checkbox" id="useBalun">
        </label>
        <label>
            Use Traps (for multi-band):
            <input type="checkbox" id="useTraps" onchange="toggleTrapOptions()">
        </label>
        <div id="trapOptions" class="hidden">
            <h3>Trap Frequencies</h3>
            <div id="trapFrequencies"></div>
            <button onclick="addTrapFrequency()">Add Trap Frequency</button>
        </div>

        <!-- Advanced Options for Fan Dipole -->
        <div id="fanDipoleOptions" class="hidden">
            <h3>Fan Dipole Elements</h3>
            <div id="fanFrequencies"></div>
            <button onclick="addFanFrequency()">Add Frequency</button>
        </div>

        <!-- Advanced Options for Hybrid -->
        <div id="hybridOptions" class="hidden">
            <h3>Hybrid Elements</h3>
            <div id="hybridElements"></div>
            <button onclick="addHybridElement()">Add Element</button>
        </div>

        <button onclick="calculateAntenna()">Calculate</button>
    </div>

    <div id="results">
        <h2>Results</h2>
        <div class="tab">
            <button class="tablinks" onclick="openTab(event, 'Design')" id="defaultOpen">Design</button>
            <button class="tablinks" onclick="openTab(event, 'Calculations')">Calculations</button>
            <button class="tablinks" onclick="openTab(event, 'TrapDesign')">Trap Design</button>
        </div>

        <div id="Design" class="tabcontent">
            <p id="resultText">Enter parameters and click Calculate to see results.</p>
            <canvas id="antennaCanvas" width="600" height="400"></canvas>
        </div>

        <div id="Calculations" class="tabcontent">
            <p id="calculationText">Calculations will appear here after clicking Calculate.</p>
        </div>

        <div id="TrapDesign" class="tabcontent">
            <p id="trapDesignText">Trap designs will appear here if traps are used.</p>
        </div>
    </div>

    <script>
        let fanFreqCount = 0;
        let hybridElementCount = 0;
        let trapFreqCount = 0;

        function toggleAdvancedOptions() {
            const antennaType = document.getElementById('antennaType').value;
            document.getElementById('fanDipoleOptions').classList.toggle('hidden', antennaType !== 'fanDipole');
            document.getElementById('hybridOptions').classList.toggle('hidden', antennaType !== 'hybrid');
            if (antennaType === 'fanDipole' && fanFreqCount === 0) {
                addFanFrequency();
            }
            if (antennaType === 'hybrid' && hybridElementCount === 0) {
                addHybridElement();
            }
            toggleTrapOptions();
        }

        function toggleTrapOptions() {
            const useTraps = document.getElementById('useTraps').checked;
            document.getElementById('trapOptions').classList.toggle('hidden', !useTraps);
            if (useTraps && trapFreqCount === 0) {
                addTrapFrequency();
            }
        }

        function addFanFrequency() {
            const fanFrequencies = document.getElementById('fanFrequencies');
            const freqId = `fanFreq${fanFreqCount}`;
            const div = document.createElement('div');
            div.innerHTML = `
                <label>
                    Additional Frequency ${fanFreqCount + 1} (MHz):
                    <input type="number" id="${freqId}" step="0.1" min="0.1" value="${7.1 + fanFreqCount * 7}">
                    <button class="remove-btn" onclick="removeFanFrequency(this)">Remove</button>
                </label>
            `;
            fanFrequencies.appendChild(div);
            fanFreqCount++;
        }

        function removeFanFrequency(button) {
            if (fanFreqCount > 1) {
                button.parentElement.parentElement.remove();
                fanFreqCount--;
            }
        }

        function addHybridElement() {
            const hybridElements = document.getElementById('hybridElements');
            const elementId = `hybridElement${hybridElementCount}`;
            const div = document.createElement('div');
            div.className = 'element-container';
            div.innerHTML = `
                <label>
                    Frequency ${hybridElementCount + 1} (MHz):
                    <input type="number" id="${elementId}Freq" step="0.1" min="0.1" value="${14.2 - hybridElementCount * 7}">
                </label>
                <label>
                    Type:
                    <select id="${elementId}Type">
                        <option value="dipole">Half-Wave Dipole</option>
                        <option value="quarterVertical">Quarter-Wave Vertical</option>
                        <option value="foldedDipole">Folded Dipole</option>
                    </select>
                </label>
                <button class="remove-btn" onclick="removeHybridElement(this)">Remove</button>
            `;
            hybridElements.appendChild(div);
            hybridElementCount++;
        }

        function removeHybridElement(button) {
            if (hybridElementCount > 1) {
                button.parentElement.remove();
                hybridElementCount--;
            }
        }

        function addTrapFrequency() {
            const trapFrequencies = document.getElementById('trapFrequencies');
            const freqId = `trapFreq${trapFreqCount}`;
            const div = document.createElement('div');
            div.innerHTML = `
                <label>
                    Trap Frequency ${trapFreqCount + 1} (MHz):
                    <input type="number" id="${freqId}" step="0.1" min="0.1" value="${14.2 - trapFreqCount * 7}">
                    <button class="remove-btn" onclick="removeTrapFrequency(this)">Remove</button>
                </label>
            `;
            trapFrequencies.appendChild(div);
            trapFreqCount++;
        }

        function removeTrapFrequency(button) {
            if (trapFreqCount > 1) {
                button.parentElement.remove();
                trapFreqCount--;
            }
        }

        function drawAntenna(antennaType, lengths, frequencies, types, velocityFactor, useBalun, balunRatio, useTraps, trapFrequencies) {
            const canvas = document.getElementById('antennaCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const centerX = canvas.width / 2;
            const baseY = canvas.height - 50;
            const maxLength = Math.max(...lengths);
            const scale = Math.min(15, (canvas.width - 80) / (maxLength * 2));
            const cutGap = 8;

            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1.5;
            ctx.font = '9px Arial';
            ctx.textAlign = 'center';

            function drawFeedPoint(x, y) {
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, 2 * Math.PI);
                ctx.fillStyle = '#FF0000';
                ctx.fill();
                ctx.fillStyle = '#000';
                ctx.fillText('F', x, y + 12);
            }

            function drawGroundPlane(x, y, length) {
                ctx.strokeStyle = '#666';
                ctx.beginPath();
                ctx.moveTo(x - length * scale, y);
                ctx.lineTo(x + length * scale, y);
                ctx.stroke();
                ctx.strokeStyle = '#000';
                ctx.fillText('G', x, y + 12);
            }

            function drawBalun(x, y, ratio) {
                ctx.fillStyle = '#00F';
                ctx.fillRect(x - 6, y - 3, 12, 6);
                ctx.fillStyle = '#000';
                ctx.fillText(ratio, x, y - 10);
            }

            function drawTrap(x, y, freq) {
                ctx.fillStyle = '#0F0';
                ctx.fillRect(x - 3, y - 3, 6, 6);
                ctx.fillStyle = '#000';
                ctx.fillText(freq.toFixed(1), x, y + 12);
            }

            if (antennaType === 'dipole' || antennaType === 'foldedDipole' || antennaType === 'endFed') {
                const length = lengths[0];
                const y = baseY / 2;
                let halfLength = length / 2;
                if (antennaType === 'endFed') halfLength = length;

                ctx.beginPath();
                if (antennaType === 'endFed') {
                    ctx.moveTo(centerX - length * scale, y);
                    ctx.lineTo(centerX, y);
                } else {
                    ctx.moveTo(centerX - halfLength * scale, y);
                    ctx.lineTo(centerX - cutGap / 2, y);
                    ctx.moveTo(centerX + cutGap / 2, y);
                    ctx.lineTo(centerX + halfLength * scale, y);
                }
                ctx.stroke();

                const feedX = antennaType === 'endFed' ? centerX - length * scale : centerX;
                drawFeedPoint(feedX, y);
                if (useBalun && balunRatio) drawBalun(feedX, y, balunRatio);

                if (useTraps && trapFrequencies.length > 0) {
                    const trapSpacing = halfLength / (trapFrequencies.length + 1);
                    trapFrequencies.forEach((freq, index) => {
                        const trapPos = trapSpacing * (index + 1);
                        if (antennaType !== 'endFed') {
                            drawTrap(centerX - trapPos * scale, y, freq);
                            drawTrap(centerX + trapPos * scale, y, freq);
                        } else {
                            drawTrap(centerX - length * scale + trapPos * scale, y, freq);
                        }
                    });
                }

                if (antennaType === 'endFed') {
                    ctx.fillText(`${length.toFixed(2)}`, centerX - length * scale / 2, y - 10);
                } else {
                    ctx.fillText(`${halfLength.toFixed(2)}`, centerX - halfLength * scale / 2, y - 10);
                    ctx.fillText(`${halfLength.toFixed(2)}`, centerX + halfLength * scale / 2, y - 10);
                }
                if (antennaType === 'foldedDipole') {
                    const height = 12;
                    ctx.beginPath();
                    ctx.moveTo(centerX - halfLength * scale, y - height);
                    ctx.lineTo(centerX + halfLength * scale, y - height);
                    ctx.lineTo(centerX + halfLength * scale, y + height);
                    ctx.lineTo(centerX - halfLength * scale, y + height);
                    ctx.lineTo(centerX - halfLength * scale, y - height);
                    ctx.stroke();
                    drawFeedPoint(centerX, y - height);
                    if (useBalun && balunRatio) drawBalun(centerX, y - height, balunRatio);
                    ctx.fillText(`${halfLength.toFixed(2)}`, centerX - halfLength * scale / 2, y - height - 10);
                    ctx.fillText(`${halfLength.toFixed(2)}`, centerX + halfLength * scale / 2, y - height - 10);
                }
            } else if (antennaType === 'quarterVertical') {
                const length = lengths[0];
                ctx.beginPath();
                ctx.moveTo(centerX, baseY);
                ctx.lineTo(centerX, baseY - length * scale);
                ctx.stroke();
                drawFeedPoint(centerX, baseY);
                if (useBalun && balunRatio) drawBalun(centerX, baseY, balunRatio);
                drawGroundPlane(centerX, baseY, length);
                if (useTraps && trapFrequencies.length > 0) {
                    const trapSpacing = length / (trapFrequencies.length + 1);
                    trapFrequencies.forEach((freq, index) => {
                        drawTrap(centerX, baseY - trapSpacing * (index + 1) * scale, freq);
                    });
                }
                ctx.textAlign = 'left';
                ctx.fillText(`${length.toFixed(2)}`, centerX + 5, baseY - length * scale / 2);
                ctx.textAlign = 'center';
            } else if (antennaType === 'fanDipole' || antennaType === 'hybrid') {
                const elementHeight = Math.min(40, (baseY - 50) / lengths.length);
                const totalHeight = (lengths.length - 1) * elementHeight;
                const startY = (baseY - totalHeight) / 2;
                let trapIndex = 0;
                lengths.forEach((length, index) => {
                    const yOffset = startY + index * elementHeight;
                    const elementType = types[index];
                    if (elementType === 'dipole') {
                        const halfLength = length / 2;
                        ctx.beginPath();
                        ctx.moveTo(centerX - halfLength * scale, yOffset);
                        ctx.lineTo(centerX - cutGap / 2, yOffset);
                        ctx.moveTo(centerX + cutGap / 2, yOffset);
                        ctx.lineTo(centerX + halfLength * scale, yOffset);
                        ctx.stroke();
                        if (index === 0) drawFeedPoint(centerX, yOffset);
                        if (useBalun && balunRatio && index === 0) drawBalun(centerX, yOffset, balunRatio);
                        if (useTraps && trapIndex < trapFrequencies.length) {
                            const trapSpacing = halfLength / (trapFrequencies.length - trapIndex + 1);
                            for (let i = trapIndex; i < trapFrequencies.length; i++) {
                                const pos = trapSpacing * (i - trapIndex + 1);
                                drawTrap(centerX - pos * scale, yOffset, trapFrequencies[i]);
                                drawTrap(centerX + pos * scale, yOffset, trapFrequencies[i]);
                            }
                            trapIndex = trapFrequencies.length;
                        }
                        ctx.fillText(`${halfLength.toFixed(2)}`, centerX - halfLength * scale / 2, yOffset - 10);
                        ctx.fillText(`${halfLength.toFixed(2)}`, centerX + halfLength * scale / 2, yOffset - 10);
                        ctx.textAlign = 'left';
                        ctx.fillText(`${frequencies[index].toFixed(1)} MHz`, centerX + halfLength * scale + 5, yOffset);
                        ctx.textAlign = 'center';
                    } else if (elementType === 'quarterVertical') {
                        ctx.beginPath();
                        ctx.moveTo(centerX, yOffset);
                        ctx.lineTo(centerX, yOffset - length * scale);
                        ctx.stroke();
                        if (index === 0) drawFeedPoint(centerX, yOffset);
                        if (useBalun && balunRatio && index === 0) drawBalun(centerX, yOffset, balunRatio);
                        drawGroundPlane(centerX, yOffset, length);
                        if (useTraps && trapIndex < trapFrequencies.length) {
                            const trapSpacing = length / (trapFrequencies.length - trapIndex + 1);
                            for (let i = trapIndex; i < trapFrequencies.length; i++) {
                                drawTrap(centerX, yOffset - trapSpacing * (i - trapIndex + 1) * scale, trapFrequencies[i]);
                            }
                            trapIndex = trapFrequencies.length;
                        }
                        ctx.textAlign = 'left';
                        ctx.fillText(`${length.toFixed(2)} (${frequencies[index].toFixed(1)} MHz)`, 
                            centerX + 5, yOffset - length * scale / 2);
                        ctx.textAlign = 'center';
                    } else if (elementType === 'foldedDipole') {
                        const halfLength = length / 2;
                        const height = 12;
                        ctx.beginPath();
                        ctx.moveTo(centerX - halfLength * scale, yOffset - height);
                        ctx.lineTo(centerX - cutGap / 2, yOffset - height);
                        ctx.moveTo(centerX + cutGap / 2, yOffset - height);
                        ctx.lineTo(centerX + halfLength * scale, yOffset - height);
                        ctx.lineTo(centerX + halfLength * scale, yOffset + height);
                        ctx.lineTo(centerX - halfLength * scale, yOffset + height);
                        ctx.lineTo(centerX - halfLength * scale, yOffset - height);
                        ctx.stroke();
                        if (index === 0) drawFeedPoint(centerX, yOffset - height);
                        if (useBalun && balunRatio && index === 0) drawBalun(centerX, yOffset - height, balunRatio);
                        if (useTraps && trapIndex < trapFrequencies.length) {
                            const trapSpacing = halfLength / (trapFrequencies.length - trapIndex + 1);
                            for (let i = trapIndex; i < trapFrequencies.length; i++) {
                                const pos = trapSpacing * (i - trapIndex + 1);
                                drawTrap(centerX - pos * scale, yOffset, trapFrequencies[i]);
                                drawTrap(centerX + pos * scale, yOffset, trapFrequencies[i]);
                            }
                            trapIndex = trapFrequencies.length;
                        }
                        ctx.fillText(`${halfLength.toFixed(2)}`, centerX - halfLength * scale / 2, yOffset - height - 10);
                        ctx.fillText(`${halfLength.toFixed(2)}`, centerX + halfLength * scale / 2, yOffset - height - 10);
                        ctx.textAlign = 'left';
                        ctx.fillText(`${frequencies[index].toFixed(1)} MHz`, centerX + halfLength * scale + 5, yOffset);
                        ctx.textAlign = 'center';
                    }
                });
            }
        }

        function calculateAntenna() {
            const frequency = parseFloat(document.getElementById('frequency').value);
            const antennaType = document.getElementById('antennaType').value;
            let velocityFactor = parseFloat(document.getElementById('velocityFactor').value);
            const wireMaterial = document.getElementById('wireMaterial').value;
            const wireGauge = parseInt(document.getElementById('wireGauge').value);
            const useBalun = document.getElementById('useBalun').checked;
            const useTraps = document.getElementById('useTraps').checked;

            const materialVF = {
                'copper': 0.95,
                'aluminum': 0.93,
                'insulated': 0.90
            };
            if (velocityFactor === 0.95 && wireMaterial !== 'copper') {
                velocityFactor = materialVF[wireMaterial];
            }

            if (isNaN(frequency) || frequency <= 0) {
                alert('Please enter a valid primary frequency');
                return;
            }
            if (isNaN(velocityFactor) || velocityFactor <= 0 || velocityFactor > 1) {
                alert('Please enter a valid velocity factor between 0 and 1');
                return;
            }
            if (wireGauge < 6 || wireGauge > 30) {
                alert('Wire gauge should be between 6 and 30 AWG');
                return;
            }

            let trapFrequencies = [];
            if (useTraps) {
                for (let i = 0; i < trapFreqCount; i++) {
                    const freq = parseFloat(document.getElementById(`trapFreq${i}`).value);
                    if (isNaN(freq) || freq <= 0) {
                        alert(`Please enter a valid trap frequency for trap ${i + 1}`);
                        return;
                    }
                    trapFrequencies.push(freq);
                }
            }

            const speedOfLight = 299792458; // meters per second
            const wavelength = speedOfLight / (frequency * 1000000);
            let results = [];
            let calcResults = [];
            let trapResults = [];
            let lengths = [];
            let frequencies = [];
            let types = [];

            function formatLength(length) {
                const feet = length * 3.28084;
                const inches = feet * 12;
                return `${length.toFixed(2)} m (${feet.toFixed(2)} ft, ${inches.toFixed(2)} in)`;
            }

            function estimateSWR(length, freq, type) {
                const idealLength = type === 'quarterVertical' ? 
                    (speedOfLight / (freq * 1000000)) * 0.25 * velocityFactor :
                    (speedOfLight / (freq * 1000000)) * 0.5 * velocityFactor;
                const deviation = Math.abs(length - idealLength) / idealLength;
                return Math.max(1, 1 + deviation * 10).toFixed(1);
            }

            function determineBalunRatio(type) {
                if (!useBalun) return null;
                switch (type) {
                    case 'endFed':
                        return '49:1';
                    case 'foldedDipole':
                        return '4:1';
                    case 'dipole':
                    case 'quarterVertical':
                    case 'fanDipole':
                    case 'hybrid':
                        return '1:1';
                    default:
                        return null;
                }
            }

            function calculateTrap(freq) {
                // Simple LC trap calculation assuming a reasonable Q and inductance
                const f = freq * 1e6; // Hz
                const L = 10e-6; // 10 µH (arbitrary starting inductance)
                const C = 1 / (4 * Math.PI * Math.PI * f * f * L); // Farads
                return { L: L * 1e6, C: C * 1e12 }; // µH and pF
            }

            const balunRatio = determineBalunRatio(antennaType);

            calcResults.push(`<b>Fundamental Constants:</b>`);
            calcResults.push(`- Speed of Light (c): ${speedOfLight} m/s - The speed at which electromagnetic waves propagate in a vacuum.`);
            calcResults.push(`- Velocity Factor (VF): ${velocityFactor} - Adjusts for slower propagation in the wire (${wireMaterial}).`);

            calcResults.push(`<b>Design Parameters:</b>`);
            calcResults.push(`- Antenna Type: ${antennaType}`);
            calcResults.push(`- Wire Material: ${wireMaterial}`);
            calcResults.push(`- Wire Gauge: ${wireGauge} AWG`);
            if (balunRatio) {
                calcResults.push(`- Balun/UnUn: ${balunRatio} - Matches impedance:`);
                if (antennaType === 'endFed') calcResults.push(`  - ~2500-3000Ω to 50Ω (49:1).`);
                if (antennaType === 'foldedDipole') calcResults.push(`  - ~300Ω to 75Ω (4:1).`);
                if (['dipole', 'quarterVertical', 'fanDipole', 'hybrid'].includes(antennaType)) 
                    calcResults.push(`  - ~50-75Ω balanced to 50Ω coax (1:1).`);
            }

            if (useTraps && trapFrequencies.length > 0) {
                trapResults.push(`<b>Trap Designs:</b>`);
                trapFrequencies.forEach((freq, index) => {
                    const { L, C } = calculateTrap(freq);
                    trapResults.push(`- Trap ${index + 1} at ${freq} MHz:`);
                    trapResults.push(`  - Inductance (L): ${L.toFixed(2)} µH`);
                    trapResults.push(`  - Capacitance (C): ${C.toFixed(2)} pF`);
                    trapResults.push(`  - Reasoning: LC circuit resonates at ${freq} MHz, blocking higher frequencies. Adjust L and C for exact tuning and Q factor.`);
                });
            }

            if (antennaType === 'dipole') {
                const length = wavelength * 0.5 * velocityFactor;
                lengths.push(length);
                frequencies.push(frequency);
                types.push('dipole');
                results.push(`Half-Wave Dipole:`);
                results.push(`- Total Length: ${formatLength(length)}`);
                results.push(`- Each Leg: ${formatLength(length / 2)}`);
                if (useTraps && trapFrequencies.length > 0) {
                    trapFrequencies.forEach((freq, index) => {
                        results.push(`- Trap at ${freq} MHz: At ~${formatLength(length / 2 / (trapFrequencies.length + 1) * (index + 1))} from feedpoint`);
                    });
                }
                if (balunRatio) results.push(`- Balun (${balunRatio}): At center feedpoint`);
                results.push(`- SWR at ${frequency} MHz: ${estimateSWR(length, frequency, 'dipole')}`);
                trapFrequencies.forEach(freq => {
                    results.push(`- SWR at ${freq} MHz: ${estimateSWR(length, freq, 'dipole')}`);
                });

                calcResults.push(`<b>Element 1: Half-Wave Dipole at ${frequency} MHz</b>`);
                calcResults.push(`- Wavelength (λ) = c / f = ${speedOfLight} / (${frequency} × 10⁶) = ${(speedOfLight / (frequency * 1000000)).toFixed(2)} m`);
                calcResults.push(`- Reasoning: λ/2 length ensures resonance at primary frequency.`);
                calcResults.push(`- Total Length = λ × 0.5 × VF = ${(speedOfLight / (frequency * 1000000)).toFixed(2)} × 0.5 × ${velocityFactor} = ${length.toFixed(2)} m`);
                calcResults.push(`- SWR at ${frequency} MHz = ${estimateSWR(length, frequency, 'dipole')}`);
                if (useTraps) {
                    calcResults.push(`- Traps divide the antenna into segments resonant at ${frequency} MHz and trap frequencies:`);
                    trapFrequencies.forEach(freq => {
                        calcResults.push(`  - ${freq} MHz: SWR = ${estimateSWR(length, freq, 'dipole')}`);
                    });
                }
            } else if (antennaType === 'quarterVertical') {
                const length = wavelength * 0.25 * velocityFactor;
                lengths.push(length);
                frequencies.push(frequency);
                types.push('quarterVertical');
                results.push(`Quarter-Wave Vertical:`);
                results.push(`- Radiator: ${formatLength(length)}`);
                results.push(`- Radial Length: ${formatLength(length)} (suggested)`);
                if (useTraps && trapFrequencies.length > 0) {
                    trapFrequencies.forEach((freq, index) => {
                        results.push(`- Trap at ${freq} MHz: At ~${formatLength(length / (trapFrequencies.length + 1) * (index + 1))} from base`);
                    });
                }
                if (balunRatio) results.push(`- Balun (${balunRatio}): At base feedpoint`);
                results.push(`- SWR at ${frequency} MHz: ${estimateSWR(length * 2, frequency, 'quarterVertical')}`);
                trapFrequencies.forEach(freq => {
                    results.push(`- SWR at ${freq} MHz: ${estimateSWR(length * 2, freq, 'quarterVertical')}`);
                });

                calcResults.push(`<b>Element 1: Quarter-Wave Vertical at ${frequency} MHz</b>`);
                calcResults.push(`- Wavelength (λ) = c / f = ${speedOfLight} / (${frequency} × 10⁶) = ${(speedOfLight / (frequency * 1000000)).toFixed(2)} m`);
                calcResults.push(`- Reasoning: λ/4 with ground plane mimics a half-wave dipole.`);
                calcResults.push(`- Radiator Length = λ × 0.25 × VF = ${(speedOfLight / (frequency * 1000000)).toFixed(2)} × 0.25 × ${velocityFactor} = ${length.toFixed(2)} m`);
                calcResults.push(`- SWR at ${frequency} MHz = ${estimateSWR(length * 2, frequency, 'quarterVertical')}`);
                if (useTraps) {
                    calcResults.push(`- Traps create multi-band resonance:`);
                    trapFrequencies.forEach(freq => {
                        calcResults.push(`  - ${freq} MHz: SWR = ${estimateSWR(length * 2, freq, 'quarterVertical')}`);
                    });
                }
            } else if (antennaType === 'foldedDipole') {
                const length = wavelength * 0.5 * velocityFactor;
                const spacing = 0.02;
                lengths.push(length);
                frequencies.push(frequency);
                types.push('foldedDipole');
                results.push(`Folded Dipole:`);
                results.push(`- Total Wire Length: ${formatLength(length * 2)}`);
                results.push(`- Each Side: ${formatLength(length)}`);
                results.push(`- Spacing: ${formatLength(spacing)}`);
                if (useTraps && trapFrequencies.length > 0) {
                    trapFrequencies.forEach((freq, index) => {
                        results.push(`- Trap at ${freq} MHz: At ~${formatLength(length / 2 / (trapFrequencies.length + 1) * (index + 1))} from feedpoint`);
                    });
                }
                if (balunRatio) results.push(`- Balun (${balunRatio}): At top center feedpoint`);
                results.push(`- SWR at ${frequency} MHz: ${estimateSWR(length, frequency, 'foldedDipole')}`);
                trapFrequencies.forEach(freq => {
                    results.push(`- SWR at ${freq} MHz: ${estimateSWR(length, freq, 'foldedDipole')}`);
                });

                calcResults.push(`<b>Element 1: Folded Dipole at ${frequency} MHz</b>`);
                calcResults.push(`- Wavelength (λ) = c / f = ${speedOfLight} / (${frequency} × 10⁶) = ${(speedOfLight / (frequency * 1000000)).toFixed(2)} m`);
                calcResults.push(`- Reasoning: λ/2 folded design increases impedance to ~300Ω.`);
                calcResults.push(`- Side Length = λ × 0.5 × VF = ${(speedOfLight / (frequency * 1000000)).toFixed(2)} × 0.5 × ${velocityFactor} = ${length.toFixed(2)} m`);
                calcResults.push(`- Total Wire = 2 × ${length.toFixed(2)} = ${(length * 2).toFixed(2)} m`);
                calcResults.push(`- SWR at ${frequency} MHz = ${estimateSWR(length, frequency, 'foldedDipole')}`);
                if (useTraps) {
                    calcResults.push(`- Traps enable multi-band operation:`);
                    trapFrequencies.forEach(freq => {
                        calcResults.push(`  - ${freq} MHz: SWR = ${estimateSWR(length, freq, 'foldedDipole')}`);
                    });
                }
            } else if (antennaType === 'endFed') {
                const length = wavelength * 0.5 * velocityFactor;
                lengths.push(length);
                frequencies.push(frequency);
                types.push('endFed');
                results.push(`End-Fed Wire:`);
                results.push(`- Total Length: ${formatLength(length)}`);
                if (useTraps && trapFrequencies.length > 0) {
                    trapFrequencies.forEach((freq, index) => {
                        results.push(`- Trap at ${freq} MHz: At ~${formatLength(length / (trapFrequencies.length + 1) * (index + 1))} from feedpoint`);
                    });
                }
                if (balunRatio) results.push(`- UnUn (${balunRatio}): At end feedpoint`);
                results.push(`- SWR at ${frequency} MHz: ${estimateSWR(length, frequency, 'endFed')}`);
                trapFrequencies.forEach(freq => {
                    results.push(`- SWR at ${freq} MHz: ${estimateSWR(length, freq, 'endFed')}`);
                });

                calcResults.push(`<b>Element 1: End-Fed Wire at ${frequency} MHz</b>`);
                calcResults.push(`- Wavelength (λ) = c / f = ${speedOfLight} / (${frequency} × 10⁶) = ${(speedOfLight / (frequency * 1000000)).toFixed(2)} m`);
                calcResults.push(`- Reasoning: λ/2 length with high impedance (~2500-3000Ω) at end.`);
                calcResults.push(`- Total Length = λ × 0.5 × VF = ${(speedOfLight / (frequency * 1000000)).toFixed(2)} × 0.5 × ${velocityFactor} = ${length.toFixed(2)} m`);
                calcResults.push(`- SWR at ${frequency} MHz = ${estimateSWR(length, frequency, 'endFed')}`);
                if (useTraps) {
                    calcResults.push(`- Traps create multi-band segments:`);
                    trapFrequencies.forEach(freq => {
                        calcResults.push(`  - ${freq} MHz: SWR = ${estimateSWR(length, freq, 'endFed')}`);
                    });
                }
            } else if (antennaType === 'fanDipole') {
                const fanFrequencies = [frequency];
                for (let i = 0; i < fanFreqCount; i++) {
                    const freq = parseFloat(document.getElementById(`fanFreq${i}`).value);
                    if (isNaN(freq) || freq <= 0) {
                        alert(`Please enter a valid frequency for element ${i + 1}`);
                        return;
                    }
                    fanFrequencies.push(freq);
                }

                results.push(`Fan Dipole:`);
                calcResults.push(`<b>Fan Dipole Elements:</b>`);
                fanFrequencies.forEach((freq, index) => {
                    const length = (speedOfLight / (freq * 1000000)) * 0.5 * velocityFactor;
                    lengths.push(length);
                    frequencies.push(freq);
                    types.push('dipole');
                    results.push(`- ${freq} MHz: ${formatLength(length)}`);
                    if (useTraps && trapFrequencies.length > 0 && index < trapFrequencies.length) {
                        results.push(`  - Trap at ${trapFrequencies[index]} MHz: At ~${formatLength(length / 2 / (trapFrequencies.length - index + 1))} from feedpoint`);
                    }
                    fanFrequencies.forEach(testFreq => {
                        results.push(`  - SWR at ${testFreq} MHz: ${estimateSWR(length, testFreq, 'dipole')}`);
                    });

                    calcResults.push(`Element ${index + 1}: Dipole at ${freq} MHz`);
                    calcResults.push(`- Wavelength (λ) = c / f = ${speedOfLight} / (${freq} × 10⁶) = ${(speedOfLight / (freq * 1000000)).toFixed(2)} m`);
                    calcResults.push(`- Total Length = λ × 0.5 × VF = ${(speedOfLight / (freq * 1000000)).toFixed(2)} × 0.5 × ${velocityFactor} = ${length.toFixed(2)} m`);
                    calcResults.push(`- SWR at ${freq} MHz = ${estimateSWR(length, freq, 'dipole')}`);
                    if (useTraps && index < trapFrequencies.length) {
                        calcResults.push(`  - Trap at ${trapFrequencies[index]} MHz isolates higher frequencies.`);
                    }
                });
                if (balunRatio) results.push(`- Balun (${balunRatio}): At common center feedpoint`);
            } else if (antennaType === 'hybrid') {
                const hybridFrequencies = [frequency];
                const hybridTypes = [document.getElementById(`hybridElement0Type`).value];
                for (let i = 1; i < hybridElementCount; i++) {
                    const freq = parseFloat(document.getElementById(`hybridElement${i}Freq`).value);
                    const type = document.getElementById(`hybridElement${i}Type`).value;
                    if (isNaN(freq) || freq <= 0) {
                        alert(`Please enter a valid frequency for element ${i + 1}`);
                        return;
                    }
                    hybridFrequencies.push(freq);
                    hybridTypes.push(type);
                }

                results.push(`Hybrid Antenna:`);
                calcResults.push(`<b>Hybrid Elements:</b>`);
                hybridFrequencies.forEach((freq, index) => {
                    const type = hybridTypes[index];
                    const length = type === 'quarterVertical' ? 
                        (speedOfLight / (freq * 1000000)) * 0.25 * velocityFactor :
                        (speedOfLight / (freq * 1000000)) * 0.5 * velocityFactor;
                    const spacing = type === 'foldedDipole' ? 0.02 : 0;
                    lengths.push(length);
                    frequencies.push(freq);
                    types.push(type);
                    if (type === 'dipole') {
                        results.push(`- Dipole at ${freq} MHz: ${formatLength(length)}`);
                        results.push(`  - Each Leg: ${formatLength(length / 2)}`);
                        if (useTraps && trapFrequencies.length > 0 && index < trapFrequencies.length) {
                            results.push(`  - Trap at ${trapFrequencies[index]} MHz: At ~${formatLength(length / 2 / (trapFrequencies.length - index + 1))} from feedpoint`);
                        }
                        calcResults.push(`Element ${index + 1}: Dipole at ${freq} MHz`);
                        calcResults.push(`- Total Length = λ × 0.5 × VF = ${(speedOfLight / (freq * 1000000)).toFixed(2)} × 0.5 × ${velocityFactor} = ${length.toFixed(2)} m`);
                    } else if (type === 'quarterVertical') {
                        results.push(`- Vertical at ${freq} MHz: ${formatLength(length)}`);
                        results.push(`  - Ground Plane: ${formatLength(length)}`);
                        if (useTraps && trapFrequencies.length > 0 && index < trapFrequencies.length) {
                            results.push(`  - Trap at ${trapFrequencies[index]} MHz: At ~${formatLength(length / (trapFrequencies.length - index + 1))} from base`);
                        }
                        calcResults.push(`Element ${index + 1}: Quarter-Wave Vertical at ${freq} MHz`);
                        calcResults.push(`- Radiator Length = λ × 0.25 × VF = ${(speedOfLight / (freq * 1000000)).toFixed(2)} × 0.25 × ${velocityFactor} = ${length.toFixed(2)} m`);
                    } else if (type === 'foldedDipole') {
                        results.push(`- Folded Dipole at ${freq} MHz: ${formatLength(length * 2)}`);
                        results.push(`  - Each Side: ${formatLength(length)}`);
                        results.push(`  - Spacing: ${formatLength(spacing)}`);
                        if (useTraps && trapFrequencies.length > 0 && index < trapFrequencies.length) {
                            results.push(`  - Trap at ${trapFrequencies[index]} MHz: At ~${formatLength(length / 2 / (trapFrequencies.length - index + 1))} from feedpoint`);
                        }
                        calcResults.push(`Element ${index + 1}: Folded Dipole at ${freq} MHz`);
                        calcResults.push(`- Side Length = λ × 0.5 × VF = ${(speedOfLight / (freq * 1000000)).toFixed(2)} × 0.5 × ${velocityFactor} = ${length.toFixed(2)} m`);
                        calcResults.push(`- Total Wire = 2 × ${length.toFixed(2)} = ${(length * 2).toFixed(2)} m`);
                    }
                    hybridFrequencies.forEach(testFreq => {
                        results.push(`  - SWR at ${testFreq} MHz: ${estimateSWR(length, testFreq, type)}`);
                    });
                    calcResults.push(`- SWR at ${freq} MHz = ${estimateSWR(length, freq, type)}`);
                    if (useTraps && index < trapFrequencies.length) {
                        calcResults.push(`  - Trap at ${trapFrequencies[index]} MHz isolates higher frequencies.`);
                    }
                });
                if (balunRatio) results.push(`- Balun (${balunRatio}): At common feedpoint`);
            }

            document.getElementById('resultText').innerHTML = results.join('<br>');
            document.getElementById('calculationText').innerHTML = calcResults.join('<br>');
            document.getElementById('trapDesignText').innerHTML = useTraps && trapFrequencies.length > 0 ? trapResults.join('<br>') : 'No traps used.';
            drawAntenna(antennaType, lengths, frequencies, types, velocityFactor, useBalun, balunRatio, useTraps, trapFrequencies);

            document.getElementById('defaultOpen').click();
        }

        function openTab(evt, tabName) {
            const tabcontent = document.getElementsByClassName('tabcontent');
            for (let i = 0; i < tabcontent.length; i++) {
                tabcontent[i].style.display = 'none';
            }
            const tablinks = document.getElementsByClassName('tablinks');
            for (let i = 0; i < tablinks.length; i++) {
                tablinks[i].className = tablinks[i].className.replace(' active', '');
            }
            document.getElementById(tabName).style.display = 'block';
            evt.currentTarget.className += ' active';
        }
    </script>
</body>
</html>
